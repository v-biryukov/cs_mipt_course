\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}
\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}

\begin{document}
\pagenumbering{gobble}

\section*{Модуль 3. ООП. Вопросы.}
\begin{enumerate}

\item \textbf{Событийно-ориентированное программирование}
\begin{enumerate}[a.]
\item \textbf{Библиотека SFML}\\
Основной цикл программы. Метод \texttt{setFramerateLimit}. Использование классов \texttt{sf::Time} и \texttt{sf::Clock} и функции \texttt{sf::sleep} для задания максимального количества кадров в секунду. Двойная буферизация. Как двойная буферизация реализована в SFML? Антиалиасинг. Как включить антиалиасинг в SFML? Системы координат SFML: система координат пикселей, глобальная система координат, локальные системы координат). Методы \texttt{mapPixelToCoords} и \texttt{mapCoordsToPixel}. 

\item \textbf{Проверка на нажатия клавиш и кнопок}\\
Проверка на нажатия клавиш клавиатуры и кнопок мыши. Функции \texttt{sf::Keyboard::isKeyPressed} и \texttt{sf::Mouse::isButtonPressed}. Чем использование этих функций отличается от использования соответствующих событий?


\item \textbf{Событийно-ориентированное программирование в библиотеке SFML}\\
Понятие событий. Событийно-ориентированное программирование. Очередь событий. Цикл обработки событий. Класс \texttt{sf::Event} и цикл обработки событий в SFML.
События SFML: \texttt{Closed}, \texttt{Resized}, \texttt{KeyPressed}, \texttt{KeyReleased}, \texttt{MouseButtonPressed},  \texttt{MouseButtonReleased}, \texttt{MouseMoved}. Получение координат мыши в событиях, связанных с мышью. Автоповтор при нажатиях на клавиши клавиатуры. Repeat delay и Repeat rate.

\item \textbf{Реализация простейших элементов графического интерфейса}
Реализация класса перетаскиваемой таблички (\texttt{Draggable}). Реализация класса кнопки. Реализация класса слайдера.
\end{enumerate}





\item \textbf{Наследование}
\begin{enumerate}[a.]
\item \textbf{Основы наследования}\\
Наследование в языке \texttt{C++}. Базовый и производный классы. Добавление новых полей и методов в производный класс. 

\item \textbf{Затенение}\\
Затенение методов и полей в производном классе. Чем затенение методов отличается от перегрузки методов? Как получить доступ к затенённым именам из базового класса? Использование ключевого слова \texttt{using} для отмены затенения.

\item \textbf{Наследование и конструкторы/деструкторы}\\
Наследуются ли конструкторы по умолчанию? Порядок вызова конструкторов при создании объекта производного класса. Как сделать так, чтобы вызывалась необходимая перегрузка конструктора базового класса при создании объекта производного класса? Использование ключевого слова \texttt{using} для наследования конструкторов. Порядок вызова деструкторов при уничтожении объекта производного класса.

\item \textbf{Модификация доступа}\\
Защищённые члены класса. Модификатор доступа \texttt{protected}. Публичное, приватное и защищённое наследование. Имеют ли друзья базового класса доступ к приватным полям производного класса?

\item \textbf{Приведение типов при наследовании}\\
Приведение объектов базового класса к объектам производного класса и наоборот. Срезка объекта. Приведение указателей на объекты базовых классов к указателям на объекты производных классов и наоборот. Использование \texttt{static\_cast} для приведения указателей. В каких случах это может привести к неопределённому поведению?

\item \textbf{Строение объекта производного класса}\\
Строение объекта производного класса. Размер объекта производного класса. Как получить объект базового класса, находящийся внутри объекта производного класса. Размер объектов класса, не содержащего полей. Empty base optimisation.

\item \textbf{Обычное множественное наследование}\\
Строение объекта производного класса при обычном (не виртуальном) множественном наследовании. Сдвиг указателей при множественном наследовании. 

\item \textbf{Виртуальное множественное наследование}\\
Проблема ромбовидного наследования. Как в языке C++ решается проблема ромбовидного наследования? Ключевое слово \texttt{virtual}. Строение объекта производного класса при виртуальном множественном наследовании.
\end{enumerate}




\item \textbf{Динамический полиморфизм}
\begin{enumerate}[a.]


\item \textbf{Определение полиморфизма}\\
Определение понятия \textit{полиморфизм}. Статический и динамический полиморфизм. Примеры статического полиморфизма в C++. Какие возможности даёт динамический полиморфизм по сравнению со статическим?

\item \textbf{Виртуальные функции}\\
Виртуальные функции. Указатели на базовый класс, хранящие адрес объекта производного класса (\texttt{Base* pbase = \&derived}). Методы какого класса будут вызываться, если мы будем вызывать их через такой указатель? Понятие \textit{полиморфный класс}.  Вызов виртуальных функций из методов классов. Виртуальные функции в конструкторах и деструкторах. Виртуальный деструктор. Переопределение методов в производных классах. Ключевые слова \texttt{override} и \texttt{final}. Приватность и виртуальные функции. 

\item \textbf{Применение динамического полиморфизма}\\
Контейнер указателей на базовый класс, хранящий адреса объектов производных классов. Хранение в поле типа "указатель на базовый класс" адреса объектов производных классов. Полиморфизм и умные указатели.

\item \textbf{Основы реализации механизма виртуальных функций}\\
Размер объектов полиморфных классов. Таблица виртуальных функций. Скрытое поле -- указатель на таблицу виртуальных функций. Сколько таблиц виртуальных функций хранится в памяти при работе программы? Как устроены таблицы виртуальных функций? Как программа понимает какой виртуальный метод вызывать?

\item \textbf{Абстрактные классы}\\
Чистая виртуальная функция. Абстрактный класс. Интерфейс. Наследование от интерфейсов. Ошибка pure virtual call. Множественное наследование от интерфейсов.

\item \textbf{RTTI}\\
Использование \texttt{static\_cast} для приведения типов и указателей на типы в иерархии наследования. Когда использование \texttt{static\_cast} может привести к неопределённому поведению? Оператор \texttt{dynamic\_cast}. Чем он отличается от \texttt{static\_cast} и в каких случая он используется? Что происходит если \texttt{dynamic\_cast} не может привести тип (рассмотрите случай приведения указателей и случай приведения ссылок)? Оператор \texttt{typeid} и класс \texttt{std::type\_info}.

\end{enumerate}




\item \textbf{Принципы проектирования}
\begin{enumerate}[a.]

\item \textbf{Принципы проектирования}\\
Какие свойства кода программ важны при написании больших программ.
Принципы SOLID. Принцип единственной ответственности. Принцип открытости/закрытости. Принцип подстановки Барбары Лисков. Принцип разделения интерфейсов. Принцип инверсии зависимостей. 
Принцип "Инкапсулируйте то, что может измениться". Принцип "Предпочитайте композицию наследованию".

\item \textbf{Паттерны проектирования}\\
Что такое паттерны проектирования? Зачем нужно использовать паттерны проектирования? Поведенческие, структурные и порождающие паттерны.


\item \textbf{UML-диаграммы}\\
UML-диаграммы. Отношения между классами: наследование, зависимость, ассоциация, агрегация, композиция. Как эти отношения отображаются на UML-диаграммах.





\end{enumerate}


\item \textbf{Поведенческие паттерны}
\begin{enumerate}[a.]
\item \textbf{Стратегия}\\
Какие проблемы решает использование паттерна Стратегия? Когда можно применять этот паттерн? Преимущества и недостатки паттерна. Примеры использования паттерна. Уметь самостоятельно написать код, использующий паттерн Стратегия.

\item \textbf{Цепочка обязанностей}\\
Когда можно применять паттерн Цепочка обязанностей? Преимущества и недостатки. Примеры использования.

\item \textbf{Наблюдатель}\\
Какие проблемы решает использование паттерна Наблюдатель? Когда можно применять этот паттерн? Преимущества и недостатки. Примеры использования. Уметь самостоятельно написать код, использующий паттерн Наблюдатель. Что такое Издатель и Подписчик в контексте этого паттерна?

\item \textbf{Команда}\\
Какие проблемы решает использование паттерна Команда? Преимущества и недостатки. Примеры использования. Уметь самостоятельно написать код, использующий паттерн Команда. Реализация класса мультикоманды (команды, состоящей из нескольких команд). Реализация операции отмены команд при использовании этого паттерна.


\item \textbf{Посетитель}\\
Когда можно применять паттерн Посетитель? Преимущества и недостатки. Примеры использования.

\item \textbf{Состояние}\\
Паттерн Состояние. Машина состояний (англ. \textit{Finite-state machine}). Какие проблемы решает использование паттерна Состояние? Когда можно применять этот паттерн? Преимущества и недостатки. Примеры использования. 

\end{enumerate}


\item \textbf{Структурные паттерны}
\begin{enumerate}[a.]
\item \textbf{Адаптер}\\
Какие проблемы решает использование паттерна Адаптер? Преимущества и недостатки. Примеры использования.

\item \textbf{Фасад}\\
Какие проблемы решает использование паттерна Фасад? Преимущества и недостатки. Примеры использования.

\item \textbf{Заместитель (Прокси)}\\
Когда можно применять паттерн Заместитель? Преимущества и недостатки. Примеры использования. Виды заместителей. Виртуальный заместитель. Удалённый заместитель. Защищающий заместитель. Кэширующий заместитель. Логирующий заместитель.

\item \textbf{Декоратор}\\
Какие проблемы решает использование паттерна Декоратор? Когда можно применять этот паттерн? Преимущества и недостатки. Примеры использования. Уметь самостоятельно написать код, использующий паттерн Декоратор. В чём отличие паттерна Декоратор от паттернов Адаптер и Заместитель?

\item \textbf{Компоновщик}\\
Какие проблемы решает использование паттерна Компоновщик? Когда можно применять этот паттерн? Преимущества и недостатки. Примеры использования.
 
\item \textbf{Мост}\\
Какие проблемы решает использование паттерна Мост? Преимущества и недостатки. Примеры использования. В чём отличие паттерна Мост от паттерна Стратегия?

\end{enumerate}

\item \textbf{Порождающие паттерны}
\begin{enumerate}[a.]
\item \textbf{Фабричный метод}\\
Какие проблемы решает использование паттерна Фабричный метод? Когда можно применять этот паттерн? Преимущества и недостатки. Примеры использования. Уметь самостоятельно написать код, использующий паттерн Фабричный метод.

\item \textbf{Абстрактная фабрика}\\
Какие проблемы решает использование паттерна Абстрактная фабрика? Когда можно применять этот паттерн? Преимущества и недостатки. Примеры использования. Уметь самостоятельно написать код, использующий паттерн Абстрактная фабрика.

\item \textbf{Строитель}\\
Какие проблемы решает использование паттерна Строитель? Преимущества и недостатки. Примеры использования.

\item \textbf{Прототип}\\
Какие проблемы решает использование паттерна Прототип? Преимущества и недостатки. Примеры использования.

\item \textbf{Синглтон}\\
Какие проблемы решает использование паттерна Синглтон? Преимущества и недостатки. Примеры использования. Уметь самостоятельно написать Синглтон.

\end{enumerate}

\end{enumerate}
\end{document}