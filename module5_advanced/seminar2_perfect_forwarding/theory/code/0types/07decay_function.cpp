#include <iostream>
#include "type_name.hpp"

using std::cout, std::endl;
/*
	Известно, что при передаче массива, в функцию он "разлагается" и неявно преобразуется в указатель на первый элемент
	Это явление называется array to pointer decay
	
	decay происходит в трёх случаях:
	
	1) 	Массив преобразуется в указатель
	2) 	Функция преобразуется в указатель на функцию
	3) 	При передаче по значению у типа убираются ссылки и const
	
	
*/

void func(int x[10])
{
    cout << "func: x size:\t" <<  sizeof(x) << endl;
    cout << "func: x type:\t" <<  typeName<decltype(x)>() << endl;
}


int main()
{
    cout << "Array decay:" << endl;
    int a[10] = {};

    cout << "main: a size:\t" <<  sizeof(a) << endl;
    cout << "main: a type:\t" <<  typeName<decltype(a)>() << endl;
    func(a);
   
}

/*
	Задачи:
	1)	Протестируйте, зависит ли тип x внутри массива от того как мы его принимаем
			void func(int x[])
			void func(int x[10])
			void func(int* x)
			
			
	2)	Пусть у нас есть двумерный массив
			int b[10][10] = {};
		Чему равен размер массива b?
		
		Если мы передадим этот массив в функцию, которая принимает такой массив
			void func2(int x[10][10])
		Какой тип будет у x внутри функции? Чему будет равен размер x?
		
	
	3) 	Пусть есть переменная
			const int&& c = 20;
		Если мы передадим её в функцию, которая принимает по значению,
			void func3(int x)
		Какой тип будет у x внутри функции.
		
		
	4) 	Можно ли передать массив в функцию по ссылке и избежать приведение массива к указателю?
		Попробуйте написать функцию, которая это делает.



*/















