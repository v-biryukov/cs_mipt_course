#include <iostream>
#include <fstream>

/*
    Один из больших недостатков кодов возврата проявляется когда ошибку
    нужно обработать не сразу, а в функциях, вызывающих данную функцию
    (это очень частый случай)

    Предположим, что у нас есть следующая задача:
    
        Нужно сгенерировать текстуру по данным из некоторого файла texture.bmp
        Если такого файла нет, то тогда мы используем файл default.bmp

        При этом, открытие файла происходит в функции loadTextureData,
        а обработать ошибку нужно в функциях, вызывающих данную

        Если файл не найдётся, то мы узнаем об этом в функции loadTextureData
        Нужно пронести сообщение об ошибке в том место, где оно понадобится.
        Для этого каждая функция в цепочке вызовов должна возвращать информацию об ошибке

    Ниже предоставлен каркас программы, которая решают задачу
    Какие недостатки такого подхода?
*/


// Загружает данные о текстуре и возвращает true если всё прошло успешно
bool loadTextureData(const std::string& filePath)
{
    // ...
    std::ifstream file(filePath);
    if (file.fail())
    {
        return false;
    }
    // ...
    return true;
}

// Вызывает loadTextureData для считывания данных о текстуре
// Затем обрабатывает эти данные и представляет текстуру в нужном нам формате
bool generateTexture(const std::string& filePath)
{
    // ...
    bool result = loadTextureData(filePath);
    if (!result)
    {
        return false;
    }
    // ...
    return true;
}



int main()
{
    bool result = generateTexture("texture.bmp");
    if (!result)
    {
        bool result = generateTexture("default.bmp");
        if (!result)
        {
            std::cout << "Error! Can't find any texture files.\n";
        }
    }
}



/* 
    Недостатки данного подхода:

    1) Код захламляется большим количеством проверок

    2) Каждая функция в цепочке вызовов теперь должна возвращать код ошибки (в данном случае bool)
       Если какой-нибудь функции потребуется вернуть что-то ещё, то код ещё сильнее усложнится

    3) Легко ошибиться, забыв обработать ошибку в любой из промежуточных функций.
       В этом случае она будет всегда возвращать корректный код (true), даже при наличии ошибки

*/