\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1.5cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{colortbl}
\usepackage{graphicx}
\pagenumbering{gobble}

\lstdefinestyle{CStyle}{
  language=C,
  basicstyle=\linespread{1.1}\ttfamily,
  basewidth=0.5em,
  texcl=true,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  backgroundcolor=\color{white},
  breaklines=true,
  breakatwhitespace=true,
  xleftmargin=5mm,
  keepspaces = true,
  extendedchars=\true,
  tabsize=4,
  upquote=true,
  emph={size_t, NULL},
  emphstyle={\color{blue}\bfseries},
}

\lstdefinestyle{longCodeStyle}{
  style=CStyle,
  framexleftmargin=5mm, 
  frame=shadowbox, 
  rulesepcolor=\color{gray}
}

\lstset{style=CStyle}


\begin{document}
\title{Семинар \#3: Строки и файлы. Классные задачи.\vspace{-5ex}}\date{}\maketitle
\section*{\centering{Таблица ASCII}}
\begin{center}
\scalebox{1}{ 
\begin{tabular}{cc | cc | cc | cc | cc | cc | cc | cc | cc | cc} 
\rowcolor[rgb]{0,0.173,0.3255}
\textcolor{white}{Символ}&\textcolor{white}{Код}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}&
\textcolor{white}{С}&\textcolor{white}{К}
\\ 
\rowcolor[rgb]{0.89451,0.93588,0.97078} 
$\backslash$0 & 0  & \& & 38 & 0  & 48 & : & 58 & D & 68 & N & 78 & X & 88                & b & 98 & l & 108 & v & 118 \\
$\backslash$t & 9  & ' & 39 & 1   & 49 & ; & 59 & E & 69 & O & 79 & Y & 89                & c & 99 & m & 109 & w & 119 \\
\rowcolor[rgb]{0.89451,0.93588,0.97078} 
$\backslash$n & 10 & ( & 40 & 2   & 50 & < & 60 & F & 70 & P & 80 & Z & 90                & d & 100 & n & 110 & x & 120 \\
              &    & ) & 41 & 3   & 51 & = & 61 & G & 71 & Q & 81 & [ & 91                & e & 101 & o & 111 & y & 121 \\
              \rowcolor[rgb]{0.89451,0.93588,0.97078} 
(пробел)       & 32 & * & 42 & 4   & 52 & > & 62 & H & 72 & R & 82 & $\backslash$ & 92     & f & 102 & p & 112 & z & 122 \\
!             & 33 & + & 43 & 5   & 53 & ? & 63 & I & 73 & S & 83 & ] & 93                & g & 103 & q & 113 & \{ & 123 \\
\rowcolor[rgb]{0.89451,0.93588,0.97078} 
"             & 34 & , & 44 & 6   & 54 & @ & 64 & J & 74 & T & 84 & \textasciicircum & 94 & h & 104 & r & 114 & | & 124 \\
\#            & 35 & - & 45 & 7   & 55 & A & 65 & K & 75 & U & 85 & \_ & 95               & i & 105 & s & 115 & \} & 125 \\
\rowcolor[rgb]{0.89451,0.93588,0.97078} 
\$            & 36 & . & 46 & 8   & 56 & B & 66 & L & 76 & V & 86 & ` & 96                & j & 106 & t & 116 & \textasciitilde & 126 \\
\%            & 37 & / & 47 & 9   & 57 & C & 67 & M & 77 & W & 87 & a & 97                & k & 107 & u & 117 &  &  \\
 \end{tabular}
}
\end{center}

\section*{Символы}
\subsection*{Целые числа \texttt{char}}
На предыдущем семинаре были рассмотрены различные типы данных, используемые для представления целых чисел. Одним из таких типов является \texttt{char} — он предназначен для хранения знаковых целых чисел размером в 1 байт, то есть в диапазоне от –128 до 127. Такой тип данных удобно использовать для работы с небольшими числами. Для ввода и вывода значений типа \texttt{char} применяется спецификатор формата \texttt{\%hhi}. Вот пример, в котором используются две переменные типа \texttt{char} как числа:
\begin{lstlisting}
char a = 10;
char b = 30;
printf("%hhi\n", a);    // Напечатает 10
printf("%i\n", a + b);  // Напечатает 40
\end{lstlisting}


\subsection*{Как хранятся символы. Кодировка ASCII.}
Все символы в памяти компьютера хранятся в виде целых чисел. Каждому символу соответствует определённый числовой код, с которым и работает процессор. Способ сопоставления символов числам называется \textit{кодировкой}. Наиболее фундаментальной и распространённой кодировкой является ASCII. Она включает базовый набор символов: латинский алфавит, цифры, специальные знаки и управляющие коды. Стандарт ASCII определяет 128 символов, и именно он лёг в основу всех последующих систем кодирования. Важно помнить, что компьютер хранит и обрабатывает символы исключительно как числа. Кодировка используется для преобразования этих чисел в символы при выводе или обратно при вводе.

Так как ASCII кодирует 128 символов, поэтому для их хранения достаточно 7 бит. Однако из-за того, что работа с байтами (8 бит) эффективнее, каждый символ всё равно занимает ровно один байт, где старший бит не используется. В языке C для хранения таких числовых кодов используется тип \texttt{char}.

\subsection*{Спецификатор \texttt{\%c} в функции \texttt{printf}}
Спецификатор \texttt{\%c} в функции \texttt{printf} предназначен для вывода символа. Он преобразует переданное целое число в соответствующий ему символ согласно таблице кодировки и печатает результат.
\begin{lstlisting}
char a = 64;
printf("%hhi\n", a);	// Напечатает 64
printf("%c\n", a);		// Напечатает @
\end{lstlisting}

\subsection*{Спецификатор \texttt{\%c} в функции \texttt{scanf}}
Спецификатор \texttt{\%c} в функции \texttt{scanf} предназначен для считывания символа.
Когда \texttt{scanf} видит такой спецификатор, он читает с экрана 1 символ, потом по таблице ASCII
получает код этого символа и этот код записывает в переменную типа \texttt{char}.
\begin{lstlisting}
char a; 
scanf("%c", &a);
printf("%c\n", a);
\end{lstlisting}

\subsection*{Символьные литералы}
Для удобства работы с символами с языке были введены символьные литералы. В коде они выглядят как символы в одинарных кавычках, но являются просто числами, соответствующими коду символа.
\begin{lstlisting}
char a = '@';  // Теперь a равно 64
char b = '5';  // Теперь b равно 53
printf("%hhi %hhi %i\n", a, b, a * b);  // Напечатает 64 53 3392
printf("%c %c\n", a, b);				// Напечатает @ 5
\end{lstlisting}

\subsection*{Примеры программ, работающих с символами}
\begin{itemize}

\item Программа, которая будет печатать на экран все символы с кодами от 32 до 126:
\begin{lstlisting}
#include <stdio.h>
int main()
{
    for (int i = 32; i <= 126; ++i)
        printf("Symbol = %c, Code = %hhi\n", i, i);
}
\end{lstlisting}

\item Программа, которая считывает один символ и если этот символ является заглавной буквой, то программа  печатает \texttt{Yes}, иначе, программа печатает \texttt{No}.
\begin{lstlisting}
#include <stdio.h>
int main()
{
    char a;
    scanf("%c", &a);
    if (a >= 65 && a <= 90)
        printf("Yes\n");
    else
        printf("No\n");
}
\end{lstlisting}
Но лучше, вместо чисел, соответствующим кодам символов использовать символьные литералы:
\begin{lstlisting}
#include <stdio.h>
int main()
{
    char a;
    scanf("%c", &a);
    if (a >= 'A' && a <= 'Z')
        printf("Yes\n");
    else
        printf("No\n");
}
\end{lstlisting}
Но ещё лучше, вместо этого использовать удобные функции из библиотеки \texttt{ctype.h}. Например, функция \texttt{isupper} проверяет, является ли символ заглавной буквой:
\begin{lstlisting}
#include <stdio.h>
#include <ctype.h>
int main()
{
    char a;
    scanf("%c", &a);
    if (isupper(a))
        printf("Yes\n");
    else
        printf("No\n");
}
\end{lstlisting}

\item Программа, которая считывает символ и, если этот символ является строчной буквой, то делает эту букву заглавной и печатает. Если символ -– не строчная буква, то просто печатает его.
\begin{lstlisting}
#include <stdio.h>
int main() 
{
    char x;
    scanf("%c", &x);
    if (x >= 'a' && x <= 'z')
        x -= ('a' - 'A');
    printf("%c\n", x);
}
\end{lstlisting}
Или то же самое с использованием функций из библиотеки \texttt{ctype.h}:
\begin{lstlisting}
#include <stdio.h>
#include <ctype.h>
int main()
{
    char x;
    scanf("%c", &x);
    if (islower(x))
        x = toupper(x);
    printf("%c\n", x);
}
\end{lstlisting}

\end{itemize}

\subsection*{Функции из библиотеки \texttt{ctype.h}}
\begin{verbatim}
isalpha - проверить, что символ - буква (A-Z или a-z)
isupper - проверить, что символ - заглавная буква (A-Z)
islower - проверить, что символ - строчная буква (a-z)
isdigit - проверить, что символ - цифра
isspace - проверить, что символ - пробельный символ (пробел, '\n' или '\t')
toupper - переводит буквы нижнего регистра в верхний регистр
tolower - переводит буквы верхнего регистра в нижний регистр
\end{verbatim}


\subsection*{Функции \texttt{putchar} и \texttt{getchar}}
Функции \texttt{putchar} и \texttt{getchar} используются для печати одного символа и считывания одного символа соответственно. Можете использовать эти функции или можете использовать функции \texttt{printf}/\texttt{scanf} со спецификатором \texttt{\%c} для печати/считывания одного символа.


\newpage
\section*{Строки}
В отличие от многих языков высокого уровня, в языке C не существует встроенного типа строки. Вместо этого строки реализованы как массивы элементов типа \texttt{char}, хранящими коды символов в определённой кодировке. Ключевая особенность, которая отличает обычный массив символов от строки, -- это обязательное наличие \textit{нуль-терминатора} (символа с кодом 0, который записывается как \texttt{'\textbackslash 0'}). Этот специальный байт, размещённый в конце последовательности символов, служит маркером конца строки.
\begin{center}
\includegraphics[scale=0.75]{../images/string_in_memory.png}
\end{center}
Следует отличать длину строки от размера массива в котором она хранится. Например, на схеме изображённой выше, длина строки равна 4, а размер массива в котором хранится эта строка равен 8. Важно помнить, что для хранения строки длиной \texttt{n} необходим массив размером не менее \texttt{n + 1} символов, так как нужно учитывать нуль-терминатор.

\subsection*{Объявление и инициализация строк}
Создавать строки можно как и массивы, но лучше через специальных синтаксис с помощью строкового литерала. 
\begin{lstlisting}
// Все три строки будут содержать "MIPT"  
char a[10] = {77, 73, 80, 84, 0};
char b[10] = {'M', 'I', 'P', 'T', '\0'};
char c[10] = "MIPT"; // Символ 0 поставится автоматически
\end{lstlisting}
Однако, после того как строка создана, её нельзя изменить путём присваивания:
\begin{lstlisting}
char a[10] = "Cat";  // OK, так можно инициализировать строку
a = "Dog";			 // Ошибка, строки нельзя присваивать целиком
\end{lstlisting}
Присваивать строки нужно либо поэлементно в цикле либо с использованием стандартной функции \texttt{strcpy}.


\subsection*{Печать строк. Спецификатор \texttt{\%s}}
Обычные массивы нельзя печатать одной командой \texttt{printf}, но специально для строк ввели модификатор \texttt{\%s}, благодаря которому можно печатать и считывать строки одной командой.
\begin{lstlisting}
char a[10] = "MIPT";
printf("%s\n", a);  // Напечатает MIPT
\end{lstlisting}
Когда \texttt{printf} видит \texttt{\%s} он начинает бежать от начала массива и печатать каждый символ пока не встретит нулевой символ. Если вдруг в массиве не будет нулевого символа, то \texttt{printf} выйдет за границы массива и это приведёт к неопределённому поведению.

\subsection*{Доступ к символам строки}
Так как строка является массивом, то для доступа к её элементам можно использовать оператор индексирования, то есть квадратные скобочки:
\begin{lstlisting}
char a[10] = "Cat";
printf("%c\n", a[2]);  	// Напечатает t

a[1] = 'o';	
printf("%s\n", a);		// Напечатает Cot
\end{lstlisting}


\subsection*{Считывание строк}
Для считывания строк с экрана используется функция \texttt{scanf} со спецификатором \texttt{\%s}. 
\begin{lstlisting}
char a[100];
scanf("%s", a); // Считываем строку, но строка должна быть меньше, чем 100 символов
                // Обратите внимание, что при считывании строк ставить \& не нужно
                // Всё потому, что строки — это массивы, а они передаются в функции по адресу
\end{lstlisting}
Более точно, \texttt{scanf} делает следующее:
\begin{enumerate}
\item Перед началом чтения \texttt{scanf} считывает и игнорирует все пробельные символы.
\item После этого \texttt{scanf} начинает считывать непробельные символы и последовательно размещать их в массиве. Этот процесс прекращается, как только встречается любой пробельный символ или достигается конец ввода (комбинация клавиш \texttt{Ctrl-D}).
\item Последний считанный пробельный символ не помещается в массив и остаётся в буфере стандартного ввода. Вместо этого \texttt{scanf} добавляет нулевой символ в конец записанной строки.
\end{enumerate}
Если вы запустите программу и введёте слишком большую строку, больше размера массива, то \texttt{scanf} выйдет за границы массива и это приведёт к неопределённому поведению.

\subsection*{Безопасное считывание строк}
Функции \texttt{scanf} можно указать максимальное количество символов для считывания:
\begin{lstlisting}
char a[100];
scanf("%99s", a); // Безопасно считываем строку
\end{lstlisting}
Теперь, если строка на входе будет больше чем 99 символов, то в массив \texttt{a} запишется только первые 99 символов входящей строки и ещё останется место на нулевой символ. Таким образом, массив не переполнится ни при какой входящей строке.

\subsection*{Считывание до определённого символа}
По умолчанию строка считывается до первого пробельного символа. Если вы хотите считать до определённого символа, то можно использовать следующий синтаксис:
\begin{lstlisting}
char a[100];
scanf("%[^X]", a);  // Считываем до первого символа X
scanf("%[^@]", a);  // Считываем до первого символа @
scanf("%[^\n]", a); // Считываем до переноса строки
\end{lstlisting}



\subsection*{Буферизация стандартного входа}
\textit{Буферизация} -- это стратегия, при которой данные не передаются сразу от источника к приёмнику, а накапливаются в промежуточной области памяти (\textit{буфере}), и только затем, при заполнении буфера или наступлении необходимых условий, передаются дальше. Буферизация входного потока -- это широко распространённая техника, используемая в программировании для ускорения операций ввода-вывода. Она применяется как при работе с файлами, так и при взаимодействии с терминалом.

В контексте языка C буферизация стандартного ввода означает, что символы, введённые вами в терминале (включая пробелы и переносы строк), не передаются программе немедленно. Вместо этого они накапливаются в специальной области памяти -- буфере. По умолчанию, при вводе в терминале буферизация работает построчно, то есть строка передаётся из терминала в буфер при нажатии на клавишу \texttt{Enter}. Функции ввода, такие как \texttt{scanf}, обращаются уже к буферу.
Понимание как работает буферизация, хотя бы на базовом уровне, необходимо, чтобы не совершать ошибки при нетривиальном считывании.


Рассмотрим как работает буферизация на следующем примере. В данной программе считывается сначала одно число, затем печатается это число. После этого считывается ещё одно число и также печатается это число.
\begin{lstlisting}
#include <stdio.h>
int main()
{
	int a;
    scanf("%i", &a);
    printf("a = %i\n", a);

	int b;
    scanf("%i", &b);
    printf("b = %i\n", b);
}
\end{lstlisting}
\begin{itemize}
\item Если сначала ввести одно число и нажать \texttt{Enter}, то программа считает число и напечатает его на экран и попросит ввести другое число. Если ввести второе число и нажать \texttt{Enter}, то программа также считает его, напечатает и завершится. В данном случае всё работает как и ожидалось.
\item Если же в терминале сразу же ввести два числа, разделённых пробелом, то программа не будет запрашивать больше чисел, а сразу же считает оба числа и напечатает их. Может показаться, что в этом случае второй вызов функции \texttt{scanf} вообще не отработал. На самом же деле, во второй раз функция \texttt{scanf} считывала число из буфера, в котором сохранилось неиспользованное число с прошлого вызова функции \texttt{scanf}. Поэтому во второй раз функция \texttt{scanf} отрабатывает мгновенно.
\end{itemize}


\subsection*{Остаточные пробельные символы в буфере}
Одна из самых частых ошибок при считывании, возникает если в буфере остались не прочтённые пробельные символы. Ошибку можно проиллюстрировать на следующем примере:
\begin{lstlisting}
#include <stdio.h>
int main()
{
    int a;
    scanf("%i", &a);		// Пользователь вводит: "123\textbackslash n"{}
    						// Считывается "123"{}, а "\textbackslash n"{} остаётся в буфере 
    char b;
    scanf("%c", &b);		// Считывает '\textbackslash n'{} из буфера
    printf("b = %i\n", b);
}
\end{lstlisting}
Для того, чтобы не допускать подобные ошибки, важно знать что конкретно происходит при вызове функции \texttt{scanf} с различными спецификаторами:
\begin{itemize}
\item \texttt{scanf} со спецификаторами для чтения чисел (\texttt{\%i}, \texttt{\%f} и т. д.):\\
Сначала "съедает"{} все пробельные символы, затем считывает символы пока они соответствуют формату числа или пока не дойдёт до конца буфера. Символы после числа, в том числе пробельные, остаются в буфере.

\item \texttt{scanf} со спецификаторами для чтения строк (\texttt{\%s}):\\
Сначала "съедает"{} все пробельные символы, затем считывает символы пока не дойдёт до пробельного символа или  до конца буфера. Символы после строки, в том числе пробельные, остаются в буфере.

\item \texttt{scanf} со спецификаторами для чтения символов (\texttt{\%c}) и функция \texttt{getchar}:\\
Просто считывает символ, ничего не "съедает"{}. Все остальные символы, остаются в буфере.

\item \texttt{scanf} со спецификаторами для чтения строки до заданного символа (\texttt{\%[\textasciicircum \textbackslash n]}):\\
Считывает все символы до заданного символа (в том числе пробельные, ничего не "съедает"{}). Заданный символ и символы, следующие после него остаются в буфере. 

\item Если \texttt{scanf} в своей строке форматирования увидит хоть один пробельный символ, то он будет "съедать"{} \textbf{все} пробельные символы пока не встретит непробельный.
\end{itemize}


\iffalse
Однако нужно быть осторожным, используя такой вид считывания. 
Дело в том, что функция \texttt{scanf} с обычными спецификаторами (такими как \texttt{\%i} или \texttt{\%s}) перед основным считыванием считывает все пробельные символы. Но, в режиме считывании до определённого символа, такого предварительного считывания пробельных символов не происходит. Поэтому, выполнение следующей программы приводит к ошибке:
\begin{lstlisting}
#include <stdio.h>
int main()
{
    int a;
    scanf("%i", &a);
    printf("a = %i\n", a);

    char str[100];
    scanf("%[^\n]", str);
    printf("str = %s\n", str);
}
\end{lstlisting}

Допустим мы запустили эту программу, ввели \texttt{123} и нажали \texttt{Enter}.
Тогда в буфере будет лежать строка \texttt{"123\textbackslash n"}. После того, как первый \texttt{scanf} отработает и считает число \texttt{123}, в буфере останется лежать лишь один символ переноса строки. Второй \texttt{scanf} должен считать до символа переноса строки, но этот символ лежит в буфере первым. Таким образом, второй \texttt{scanf} не считает ничего и строка \texttt{str} останется неинициализированной.
\fi


\section*{Стандартные функции библиотеки \texttt{string.h}}
\begin{itemize}
\item \texttt{size\_t strlen(const char str[])} - возвращает длину строки
\item \texttt{char* strcpy (char a[], const char b[]))} - копирует строку \texttt{b} в строку \texttt{a}, т.е. аналог \texttt{a = b}.
\item \texttt{char* strcat(char a[], const char b[])} - приклеивает копию строки \texttt{b} к строке \texttt{a}, т.е. аналог \texttt{a += b}.
\item \texttt{int strcmp(const char a[], const char b[])} - лексикографическое сравнение строк (возвращает \texttt{0}, если строки одинаковые, положительное, если первая строка больше, и отрицательное, если меньше)
\item \texttt{sprintf} - аналог \texttt{printf}, но вместо печати на экран, 'печатает' в строку.
\item \texttt{sscanf} - аналог \texttt{scanf}, но вместо считывания на экран, 'считывает' из строки.
\end{itemize}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
int main() 
{
    char a[100] = "Cat";
    char b[100] = "Dog";
	
    // Строки это массивы, поэтому их нельзя просто присваивать 
    a = b; // Это не будет работать! Нужно использовать strcpy:
    strcpy(a, b);
    
    // Конкатенация (склейка) строк. Можно воспринимать как +=
    a += b; // Это не будет работать! Нужно использовать strcat:
    strcat(a, b);
	
    // Строки это массивы, поэтому их нельзя просто сравнивать
    if (a == b) {} // Это не будет работать! Нужно использовать strcmp:
    if (strcmp(a, b) == 0)) {} 
    
    // Печатаем в строку. После этого в a будет лежать строка "(10:20)"
    sprintf(a, "(%i:%i)", 10, 20);
}
\end{lstlisting}


\newpage
\section*{Аргументы командной строки}
Программы могут принимать аргументы. Простейший пример -- утилита \texttt{ls}. Если запустить \texttt{ls} без аргументов:
\begin{verbatim}
    ls
\end{verbatim}
то она просто напечатает содержимое текущей директории.  Если же использовать эту программу с опцией \texttt{-l}: 
\begin{verbatim}
    ls -l
\end{verbatim}
то на экран выведется подробное описание файлов и папок в текущей директории.
Поведение программы \texttt{ls} изменилось так как изменились её аргументы командной строки.
Или, например, когда мы компилируем программу, мы пишем что-то вроде этого:
\begin{verbatim}
    gcc main.c -o result
\end{verbatim}
В данном случае, строки \texttt{"gcc"}, \texttt{"main.c"}, \texttt{"\--o"} и \texttt{"result"} являются аргументами командной строки. Обратите внимание, что название программы тоже считается аргументом командной строки.\\

В случае передачи информации программе через аргументы командной строки, информация передаётся при вызове 
программы. Чтобы передать что-либо программе через аргументы командной строки, нужно
написать это в терминале при запуске программы сразу после её запуска.

Например, если мы хотим передать программе \texttt{a.out} строку \texttt{cat}, то программу нужно вызвать так:
\begin{verbatim}
    ./a.out cat
\end{verbatim}

Если же мы хотим передать программе \texttt{a.out} число \texttt{123}, то программу нужно вызвать так:
\begin{verbatim}
    ./a.out 123
\end{verbatim}
Только нужно помнить, что аргументы командной строки всегда воспринимаются как строки и в данном случае 
число \texttt{123} передастся как строка \texttt{"123"}. \\

Если же мы хотим передать несколько аргументов, то
просто перечисляем их через пробел:
\begin{verbatim}
    ./a.out mouse elephant
\end{verbatim}



Аргументы командной строки можно получить в программе если использовать специальный вариант функции \texttt{main} с двумя аргументами, которые обычно называют \texttt{argc} и \texttt{argv}. Вот пример программы, которая печатает на экран все аргументы командной строки:

\begin{lstlisting}
#include <stdio.h>
int main(int argc, char** argv) 
{
    for (int i = 0; i < argc; ++i)
    {
        printf("%s\n", argv[i]);
    }
}
\end{lstlisting}

\begin{itemize}
\item \texttt{argc} -- это количество аргументов командной строки
\item \texttt{argv} -- это массив строк размера \texttt{argc}. Каждый элемент этого массива -- это соответствующий
аргумент командной строки. 
\end{itemize}
\begin{center}
\includegraphics[scale=1]{../images/argv.png}
\end{center}

\newpage

\section*{Работа с текстовыми файлами}
Текстовые файлы -- это такие файлы, которые содержат только текст.
В данном семинаре будем рассматривать только текстовые файлы в кодировке ASCII.
Рассмотрим простейшую программу, которая создаёт файл \texttt{myfile.txt} и записывает туда строку \texttt{"Hello world!"}:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int main() 
{
    FILE* fp = fopen("myfile.txt", "w");
    if (fp == NULL) 
    {
        printf("Error!\n");
        exit(1);
    }
    fprintf(fp, "Hello world!");
    fclose(fp);
}
\end{lstlisting}

Разберём эту программу подробно:

\begin{itemize}
\item Функции для работы с файлами хранятся в библиотеке \texttt{stdio.h}.
\item Подключаем библиотеку \texttt{stdlib.h}, так как будем использовать функцию \texttt{exit} для выхода из программы.
\item Функция \texttt{fopen} используется для открытия файла. Ей нужно передать название название файла и режим открытия файла.
\item Путь до файла считается от исполняемого файла. То есть, в данном примере, новый файл \texttt{myfile.txt} появится в той же папке, что и исполняемый файл.
\item Основные режимы открытия файла: 
\begin{itemize}
\item  \texttt{"r"} -- открыть существующий файл для чтения (read). Если файл не существует, то функция вернёт значение \texttt{NULL}.
\item \texttt{"w"} -- создать новый файл и открыть его для записи (write). Если файл с таким именем уже существует, то его содержимое удалится перед записью.
\item \texttt{"a"} -- открыть для записи в конец файла (append). Если файл не существует, то он будет создан.
\end{itemize}

\item Функция \texttt{fopen} возвращает специальный объект типа \texttt{FILE*} -- указатель на структуру \texttt{FILE}. Используя этот объект, мы будем взаимодействовать с файлом. \texttt{fopen} возвращает \texttt{NULL} если при попытке открытия файла произошла ошибка.

\item Функция \texttt{fprintf} используется для печати в файл. Она очень похожа на функцию \texttt{printf}, только первым аргументом нужно передать указатель, который мы получили из функции \texttt{fopen}.

\item Аналогично, существует функция \texttt{fscanf}, которая считывает из файла и работает очень похоже на функцию \texttt{scanf}, только первым аргументом нужно передать указатель, который мы получили из функции \texttt{fopen}.

\item Функция \texttt{fclose} закрывает файл. При закрытии файла освобождаются все ресурсы, которые были выделены предыдущими функциями.
\end{itemize}


\subsection*{Глобальные потоки \texttt{stdout} и \texttt{stdin}}
В стандартной библиотеке определены глобальные переменные \texttt{stdout} и \texttt{stdin}, имеющие тип \texttt{FILE*}.
Эти переменные соответствуют стандартному выводу (печать на экран) и стандартному вводу (считывание с экрана). Их можно использовать для передачи в функции для работы с файлами. Например:
\begin{lstlisting}
printf("Hello\n");              // Печатает Hello на экран
fprintf(stdout, "Hello\n");     // Тоже печатает Hello на экран
\end{lstlisting}


\subsection*{Посимвольное чтение и запись}
Ещё одна функция, которая может быть очень полезна для считывания из файла -- это функция \texttt{fgetc}.
\begin{itemize}
\item \texttt{int fgetc(FILE* file)} -- читает один символ из файла и возвращает его ASCII код. Если символов не осталось, то функция возвращает специальное значение, равное константе \texttt{EOF} (обычно она равна \texttt{-1}).
Обратите внимание, что функция возращает значение типа \texttt{int}, а не \texttt{char}. Это необходимо, так как возвращаемое значение может принимать ещё одно дополнительное значение (\texttt{EOF}) в дополнении ко всем возможным кодам символов.
\item \texttt{int fputc(int c, FILE* file)} -- записывает символ, соответствующий коду \texttt{c}, в файл.
\end{itemize}

Пример программы, которая находит количество символов, являющимися цифрами, в файле:
\begin{lstlisting}
#include <stdio.h>
int main() 
{
    FILE* f = fopen("input.txt", "r");
    int c; 
    int num_of_digits = 0;

    while ((c = fgetc(f)) != EOF) 
    {
        if (c >= '0' && c <= '9')
            num_of_digits += 1;
    }
    printf("Number of digits = %d\n", num_of_digits);
    fclose(f);
}
\end{lstlisting}



\iffalse
\newpage
\subsection*{Чтение слов из файла}
Пример программу, которая подсчитывает количество слов в файле.
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
int main() 
{
    // Считывание слов из файла
    FILE* infile = fopen("words.txt", "r");
    char words[500][100];
    int number_of_words = 0;
    while (fscanf(infile, "%s", words[number_of_words]) != -1) {
        number_of_words++;
    }
    fclose(infile);
}
\end{lstlisting}
\fi


\end{document}