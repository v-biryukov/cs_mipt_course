/*
    Передача структуры в функции по константному указателю

    Иногда мы не хотим менять структуру внутри функции, но хотим чтобы ничего не копировалось.
    Ведь копирование большой структуры может быть очень долгим, неэффективным.
    Тогда желательно использовать передачу по указателю на константу.

    Например, рассмотрим функцию, которая печатает структуру на экран:

        void print_book(Book b) 
        {
            printf("Book: %s, Pages: %i, Price: %g\n", b.title, b.pages, b.price);
        }

    Эта функция не эффективна, так как структра копируется внутри функции, это медленно.
    Если мы передадим в функцию указатель, то всё будет более эффективно:

        void print_book(Book* pb) 
        {
            printf("Book: %s, Pages: %i, Price: %g\n", pb->title, pb->pages, pb->price);
        }

    Однако в этом случае мы не сможем быть уверены, что структура не изменится внутри функции.
    Конечно, в случае функции print_book мы явно видим, что структура там не меняется.
    Но представьте, что вы работаете с функцией, которая гораздо больше, чем функция print_book
    и которую написал другой программист и, более того, эта функция из уже скомпилированной библиотеки
    и вы даже не можете посмотреть на её исходный код. 
    Понять в этом случае изменится ли ваша структура внутри функции или нет почти невозможно.
    Это всё сильно усложняет программирование, так как ваша структура может измениться в любой функции куда вы её передаёте.

    Поэтому все программисты, чтобы указать, что структура внутри функции не изменится принимают структуру
    по константному указателю:

        void print_book(const Book* b) 
        {
            printf("Book: %s, Pages: %i, Price: %g\n", pb->title, pb->pages, pb->price);
        }
*/

#include <stdio.h>

struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;

void print_book(const Book* pb) 
{
    printf("Book: %s, Pages: %i, Price: %g\n", pb->title, pb->pages, pb->price);
}

int main() 
{
    Book a = {"The Martian", 300, 500};
}

/*
    Задачи:

        1)  Напишите функцию is_expensive которая будет принимать книгу по константному указателю
            и возвращать 1, если книга стоит дороже 1000 рублей и 0 иначе.

        2)  Напишите функцию get_price_by_page которая будет принимать книгу по константному указателю
            и возращать цену книги на одну страницу (то есть отношени price / pages).
*/