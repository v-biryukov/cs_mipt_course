\documentclass[10pt]{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage[left=2cm, right=2cm, top=1.5cm, bottom=1.5cm]{geometry}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage[shortlabels]{enumitem}
\usepackage{hyperref}
\pagenumbering{gobble}

\lstdefinestyle{CStyle}{
  language=C,
  basicstyle=\linespread{1.1}\ttfamily,
  basewidth=0.5em,
  texcl=true,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  backgroundcolor=\color{white},
  breaklines=true,
  breakatwhitespace=true,
  xleftmargin=5mm,
  keepspaces = true,
  extendedchars=\true,
  tabsize=4,
  upquote=true,
  emph={size_t, NULL},
  emphstyle={\color{blue}\bfseries},
  literate={~}{{\raisebox{0.5ex}{\texttildelow}}}{1},
}
\lstdefinestyle{boxStyle}{
  style=CStyle,
  framexleftmargin=5mm, 
  frame=shadowbox, 
  rulesepcolor=\color{gray}
}
\lstset{style=CStyle}


\begin{document}
\title{Семинар \#4: Часть 2: Структуры\vspace{-5ex}}\date{}\maketitle

\section*{Основы структур}

Структуры -- это композитный тип данных, объединяющий набор объектов в один объект. Структуры позволяют нам создавать собственные типы данных, используя существующие как строительные блоки.

Предположим, что мы разрабатываем приложение для работы с двумерной графикой и нам понадобилось как-то описывать точку в двумерном пространстве. Для этого  мы можем опеределить структуру точки, как это сделано в следующем примере:
\begin{lstlisting}
#include <stdio.h>

struct point 
{
    float x;
    float y;
};

int main() 
{
    struct point a = {0.5, 1.5};
    a.x = 2.0;
    printf("(%g, %g)\n", a.x, a.y); // Напечатает (2.0, 1.5)
}
\end{lstlisting}
\subsubsection*{Пояснение по коду:}
\begin{itemize}
\item Сначала мы определили новую структуру с двумя полями \texttt{x} и \texttt{y} типа \texttt{float}. Таким образом, мы создали новый тип данных -- \texttt{struct point} (да, название типа состоит из двух слов).
\item \texttt{!} Не забывайте ставить точку с запятой в конце определения структуры.
\item Далее, в функции \texttt{main}, создаём переменную типа \texttt{struct point} по имени \texttt{a} и сразу инициализируем её.
\item Переменная \texttt{a} типа \texttt{struct point} хранит в себе два объекта типа \texttt{float} по имени \texttt{x} и \texttt{y}.
\item Получить доступ к внутренностям переменной \texttt{a} можно с помощью оператора \texttt{.} (точка).
\end{itemize}



\subsection*{Допустимые операции со структурами}
\begin{enumerate}
\item При создании структуры её элементы можно инициализировать с помощью фигурных скобочек.
\begin{lstlisting}
struct point a = {1.0, 2.5};
\end{lstlisting}
Однако нельзя таким образом присваивать
\begin{lstlisting}
a = {2.0, 1.0}; // Ошибка, фигурные скобки работают только при объявлении
\end{lstlisting}
\item Доступ к элементу структуры осуществляется с помощью оператора точка
\begin{lstlisting}
a.x = 5.5;
a.y = 3.0;
\end{lstlisting}
\item Структуры можно присваивать друг другу. При этом происходит побайтовое копирование содержимого одной структуры в другую.
\begin{lstlisting}
struct point b;
b = a;
\end{lstlisting}
\end{enumerate}

\subsection*{Массив структур}
Структуры, как и обычные переменные, можно хранить в массивах. В примере ниже создан массив под названием \texttt{array}, содержащий в себе 3 точки.
\begin{lstlisting}
#include <stdio.h>

struct point 
{
    float x
    float y;
};

int main() 
{
    struct point array[3] = {{1.1, 2.2}, {3.3, 4.4}, {5.5, 6.6}};
    array[1].y = 9.9;
    printf("(%g, %g)\n", array[1].x, array[1].y); // Напечатает (3.3, 9.9)
}
\end{lstlisting}

\subsection*{Передача структуры в функцию}
Структуры можно передавать в функции и возвращать из функций также как и обычные переменных. При передаче в функцию происходит полное копирование структуры и функция работает уже с копией структуры. При возвращении из функции также происходит копирование.
\begin{lstlisting}
#include <stdio.h>

struct point 
{
    float x;
    float y;
};

void print_point(struct point a) 
{
    printf("(%g, %g)", a.x, a.y);
}

struct point add_points(struct point a, struct point b) 
{
    struct point result;
    result.x = a.x + b.x;
    result.y = a.y + b.y;
    return result;
}

int main() 
{
    struct point a = {1.1, 2.2}; 
    struct point b = {3.3, 4.4};
    struct point c = add_points(a, b);
    print_point(c);
}
\end{lstlisting}

\newpage
\subsection*{Структуры содержащие более сложные типы данных}
Структуры могут содержать в себе не только базовые типы данных, но и более сложные типы, такие как массивы (в том числе строки), указатели, а также другие структуры.\\
Пример программы, в которой описывается структура для удобной работы с объектами Книга (\texttt{struct book}).
\begin{lstlisting}
#include <stdio.h>
#include <string.h>

struct book 
{
    char title[50];
    int pages;
    float price;
};

void print_book(struct book b) 
{
    printf("Book info:\n");
    printf("Title: %s\nPages: %d\nPrice: %g\n\n", b.title, b.pages, b.price);
}

int main() 
{
    struct book a = {"The Martian", 10, 550.0};
    print_book(a);
    
    a.pages = 369;
    strcpy(a.title, "The Catcher in the Rye");
    print_book(a);
    
    struct book scifi_books[10] = 
    {
        {"Dune", 300, 500.0}, 
        {"Fahrenheit 451", 400, 700.0},
        {"Day of the Triffids", 304, 450.0}
    };
    scifi_books[2].price = 2000.0;
    print_book(scifi_books[2]);
}
\end{lstlisting}

\subsection*{Создаём более удобное имя для типа структуры, используя \texttt{typedef}}
По умолчанию для структуры создаётся имя типа, состоящее из двух слов, например \texttt{struct book}. Это может быть не очень удобно, так как использование такого имени делает ваш код многословным. Чтобы укоротить имя типа можно использовать ключевое слово \texttt{typedef}:
\begin{lstlisting}
struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;
// После этого можно использовать имя Book для названия типа структуры
\end{lstlisting}


\newpage
\section*{Указатели на структуры:}
Указатель на структуру хранит адрес первого байта структуры. Для доступа к полям структуры по указателю нужно сначала этот указатель разыменовать, а потом использовать: \texttt{(*p).price}. Для удобства был введён оператор стрелочка \texttt{->}, который делает то же самое: \texttt{p->price}.
\begin{multicols}{2}
\begin{lstlisting}
#include <stdio.h>

struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;

int main() 
{
    Book a = {"The Martian", 277, 540};
    Book* p = &a;
    
    // Три способа доступа к полю:
    a.price += 10;
    (*p).price += 10;
    p->price += 10;
}
\end{lstlisting}
\vfill\null
\columnbreak
\vspace*{3\baselineskip}
\begin{center}
\includegraphics[scale=0.5]{../images/structpointer2.png}
\end{center}
\end{multicols}


\subsection*{Передача по значению}
При обычной передаче в функцию всё содержимое копируется. Функция работает с копией.
\begin{multicols}{2}
\begin{lstlisting}
#include <stdio.h>

struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;

void change(Book a) 
{
    a.price += 10;
}
int main()
{
    Book a = {"The Martian", 277, 540};
    change(a); // a НЕ изменится
}
\end{lstlisting}
\vfill\null
\columnbreak
\vspace*{3\baselineskip}
\begin{center}
\includegraphics[scale=0.5]{../images/structpassbyvalue.png}
\end{center}
\end{multicols}


\subsection*{Передача по указателю}
При передаче в функцию по указателю копируется только указатель.
\begin{multicols}{2}
\begin{lstlisting}
#include <stdio.h>
struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;

void change(Book* p) 
{
    p->price += 10;
}
int main() 
{
    Book a = {"The Martian", 277, 540};
    Book* p = &a;
    change(p); // структура a изменится
}
\end{lstlisting}
\vfill\null
\columnbreak
\begin{center}
\includegraphics[scale=0.5]{../images/structpassbypointer.png}
\end{center}
\end{multicols}

\noindent Такой способ передачи имеет 2 преимущества:
\begin{enumerate}
\item Можно менять структуру внутри функции, и изменения будут действительны вне функции
\item Не приходится копировать структуры, поэтому программа работает быстрее.
\end{enumerate}

\subsection*{Передача по константному указателю}
Иногда мы не хотим менять структуру внутри функции, но хотим избежать дорогостоящего копирования. Тогда желательно использовать передачу по константному указателю.
\begin{lstlisting}
#include <stdio.h>
struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;

void print_book(const Book* p) 
{
    printf("Title: %s\nPages: %d\nPrice: %g\n\n", p->title, p->pages, p->price);
}

int main() 
{
    Book a = {"The Martian",277,540};
    print_book(&a);
}
\end{lstlisting}

Если структура передаётся в функцию по константному указателю, это гарантирует, что содержимое структуры не будет изменено внутри функции через этот указатель. Это особенно важно в больших проектах с тысячами файлов и миллионами строк кода.

Если передавать структуру по неконстантному указателю, то внутри функции нельзя быть уверенным, что данные останутся неизменными. Более того, этот указатель может быть передан дальше в другие функции, где структура потенциально изменится. В результате становится сложно отследить, в каком месте программы произошли изменения.

Использование \texttt{const} снимает такие сомнения: программист и компилятор получают явную гарантию, что данные останутся неизменными. Это облегчает сопровождение кода, делает интерфейсы функций более предсказуемыми и помогает избежать трудноуловимых ошибок.

\subsection*{Возможность изменения структуры при передаче по константному указателю}
В языке C передача структуры по указателю на \texttt{const} не даёт абсолютной гарантии неизменности данных. Формально константность можно обойти, приведя \texttt{const Book*} к \texttt{Book*} и изменив содержимое через полученный указатель. При этом, если объект на который указывает указатель сам не является константным, то такое изменение будет даже корректным с точки зрения языка и не приведёт к неопределённому поведению.
\begin{lstlisting}
#include <stdio.h>
struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;

void print_book(const Book* p) 
{
    printf("Title: %s\nPages: %d\nPrice: %g\n\n", p->title, p->pages, p->price);
}

void change(const Book* p) 
{
    Book* q = (Book*)p;
    q->pages += 100;
}

int main() 
{
    Book a = {"The Martian", 277, 540};
    change(&a);  // Структура a изменится
    print_book(&a);
}
\end{lstlisting}
Тем не менее на практике это не является проблемой так как:
\begin{itemize}
\item снятие \texttt{const} считается грубым нарушением стиля и почти не встречается в корректном коде.
\item такие преобразования легко заметить при ревью кода или статическом анализе.
\end{itemize}

\noindent 
Аналогичные принципы применимы не только к структурам, но и к любым данным (переменным, массивам/строкам), переданным по константному указателю.

\newpage


\newpage
\section*{Выравнивание}
Пусть есть структура \texttt{struct cat} и нам нужно узнать её размер, если размеры типов \texttt{char}, \texttt{int} и \texttt{double} равны \texttt{1}, \texttt{4} и \texttt{8} байт соответственно.
\begin{lstlisting}
struct cat 
{
    int x;
    char y;
    double z;
};
\end{lstlisting}
Кажется, что размер этой структуры равен сумме размеров состовляющих её элементов, то есть 13 байт, но это не так. На самом деле, размер этой структуры будет отличаться в зависимости от вычислительной системы, на которой запускается код (как, впрочем, и размеры других типов). Но на большинстве вычислительных систем размер структуры \texttt{cat} будет равен 16 байт. Это можно проверить с помощью следующего кода:
\begin{lstlisting}
#include <stdio.h>
struct cat 
{
    int x;
    char y;
    double z;
};
int main() 
{
    printf("Size of char   = %zu\n", sizeof(char));			// Напечатает 1
    printf("Size of int    = %zu\n", sizeof(int));			// Напечатает 4
    printf("Size of double = %zu\n", sizeof(double));		// Напечатает 8
    printf("Size of cat    = %zu\n", sizeof(struct cat));	// Напечатает 16
}
\end{lstlisting}
Так происходит потому что компьютер работает более эффективно с объектами, которые лежат в памяти по адресу, кратному некоторой величине, называемой выравниванием. Например, с числами типа \texttt{double} компьютер обычно работает более эффективно, если они лежат по адресам, кратным 8-ми. Поэтому в памяти структура \texttt{cat} обычно выглядит так: 

\begin{center}
\includegraphics[scale=1]{../images/alignment.png}
\end{center}
Можно считать, что каждый тип данных, помимо размера, характеризуется ещё одной величиной - выравниванием. Выравнивание - это некоторое значение в байтах. Оно означает, что объекты данного типа будут располагаться в памяти по адресам, кратным выравниванию.

\noindent Для того, чтобы найти величину выравнивания можно использовать оператор \texttt{alignof}:
\begin{lstlisting}
int a;
struct cat b;
printf("Alignment of int = %zu\n", alignof(a));  // На большинстве систем напечатает 4
printf("Alignment of int = %zu\n", alignof(b));  // На большинстве систем напечатает 8
\end{lstlisting}
Значения выравниваний для разных типов зависит от системы. Обычно (но не всегда) верно следующее:
\begin{itemize}
\item Для скалярных типов выравнивание равно размеру типа.
\item Для структур выравнивание равно максимальному значению выравнивания элемента структуры.
\end{itemize}
 

\newpage
\noindent Рассмотрим ещё пример выравнивания для следующей структуры:
\begin{lstlisting}
struct dog 
{
    char x;
    int y;
    char z;
};
\end{lstlisting}
Эта структура на большинстве систем будет занимать 12 байт и в памяти будет выглядеть вот так:
\begin{center}
\includegraphics[scale=1]{../images/alignment2.png}
\end{center}
Выравнивание у типа \texttt{char} равно 1, поэтому объекты этого типа могут располагаться где угодно, а выравнивание у типа \texttt{int} равно 4, поэтому объекты этого типа желательно располагать по адресам, кратным четырём. Это объясняет, почему при расположении числа типа \texttt{int} после числа типа \texttt{char} был сделан отступ в 3 байта.

Также обратите внимание, что в этом случае неиспользуемые байты были добавлены в конец структуры. Зачем это было нужно? Представьте, что мы создали массив из структур \texttt{dog}. Все элементы массива в памяти должны лежать плотно примыкая друг к другу, при этом все поля всех структур в массиве должны быть выравнены. Это можно добиться только добавив три неиспользуемых байта в конец структуры.

Интересно, что размер структуры может зависеть от порядка полей структуры. Например, если мы просто поменяем порядок полей в структуре \texttt{dog} вот так:
\begin{lstlisting}
struct dog2 
{
    char x;
    char z;
    int y;
};
\end{lstlisting}
то размер этой структуры уже будет равен 8 байт, а в памяти структура будет выглядеть следующим образом:
\begin{center}
\includegraphics[scale=1]{../images/alignment3.png}
\end{center}

\subsection*{Задание выравнивания}
Задать значения выравнивания в языке C можно с помощью атрибута \texttt{alignas}.
\begin{lstlisting}
#include <stdio.h>
#include <stdalign.h>

struct cat 
{
    char x;
    alignas(32) int y;	// Теперь у поля y будет выравнивание 32, а не 4
    alignas(64) char z;	// Теперь у поля z будет выравнивание 64, а не 1
};

int main() 
{
    printf("%zu\n", sizeof(struct cat));	// Напечатает 128
    printf("%zu\n", alignof(struct cat));	// Напечатает 64
}
\end{lstlisting}
Значение выравнивания может принимать только степени двойки и с помощью \texttt{alignas} его можно только увеличить, но не уменьшать.

\subsection*{Уменьшение выравнивания}
По стандарту языка C уменьшить выравнивание нельзя. Но компиляторы обычно предоставляют дополнительные возможности, позволяющие уменьшить выравнивания всех полей структуры до единицы. Обычно делать это не рекомендуется, так как доступ к невыровненным данным медленнее. Тем не менее иногда это может понадобиться, если нужно уменьшить размер структуры, пожертвовав производительностью. На компиляторе gcc это можно сделать так:

\begin{lstlisting}
#include <stdio.h>

struct __attribute__((packed)) cat 
{
    char a;
    int b;   // будет идти сразу за c, без выравнивания
    char c;
};

int main() 
{
    printf("%zu\n", sizeof(struct cat));	// Напечатает 6
    printf("%zu\n", alignof(struct cat));	// Напечатает 1
}
\end{lstlisting}
На других компиляторах, аналогичный код будет выглядеть по-другому.

\end{document}