/*
    Сегмент памяти Стек

    Стек также используется для того, чтобы хранить данные, необходимые для работы функций.
    Когда функция вызывается, то в стеке выделяется необходимое количество памяти.
    Эта память нужна для хранения локальных переменных функции и аргументов функции.
    Также в стеке будет храниться информация, нужная для завершения функции и возврата в то место
    программы, откуда данная функция была вызвана.
*/

#include <stdio.h>

void funca();
void funcb();
void funcc();


void funca()
{
    int a;
    printf("Call funca. Address of a = %p\n", &a);
    funcb();
    funcc();
}

void funcb()
{
    int b;
    printf("Call funcb. Address of b = %p\n", &b);
    funcc();
}


void funcc()
{
    int c;
    printf("Call funcb. Address of c = %p\n", &c);
}


int main()
{
    funca();
}

/*
    Рассмотрим пример данного примера подробно:

        1)  Сначала программа заходит в функцию main и её стек можно изобразить так:


                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╚══════════════════════════════╝

        2)  Потом программа заходит в функцию funca и для этой функции выделяется необходимая ей память на стеке.
            Обычно стек растёт в сторону меньших адресов, поэтому адреса переменных функции funca будут меньше адресов
            переменных функции main.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╚══════════════════════════════╝


        3)  Потом программа, в функции funca, заходит в функцию funcb и для этой функции тоже выделяется необходимая 
            ей память на стеке.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funcb     ║
                ║                              ║
                ╚══════════════════════════════╝


        4)  Потом программа, в функции funcb, заходит в функцию funcc и для этой функции тоже выделяется необходимая 
            ей память на стеке.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funcb     ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funcc     ║
                ║                              ║
                ╚══════════════════════════════╝


        5)  Потом программа выходит из функции funcc и память, которая использовалась этой функцией освобождается.
            "Освобождение" памяти заключается лишь в том, что операционная система изменяет лишь одно число, 
            в которой хранится конец стека. Никакая память при этом не затирается другими значениями.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funcb     ║
                ║                              ║
                ╚══════════════════════════════╝


        6)  Потом программа выходит из функции funcb и память, которая использовалась этой функцией освобождается.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╚══════════════════════════════╝


        7)  Потом программа, в функции funca, заходит в функцию funcc и для этой функции тоже выделяется необходимая 
            ей память на стеке. Обратите внимание, что теперь функция funcc будет использовать ту память, которую
            раньше использовала функция funcb.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funcc     ║
                ║                              ║
                ╚══════════════════════════════╝

        8)  Потом программа выходит из функции funcc и память, которая использовалась этой функцией освобождается.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╟──────────────────────────────╢
                ║                              ║
                ║     Память функции funca     ║
                ║                              ║
                ╚══════════════════════════════╝


        9)  Потом программа выходит из функции funca и память, которая использовалась этой функцией освобождается.

                Стек:
                ╔══════════════════════════════╗
                ║                              ║
                ║     Память функции main      ║
                ║                              ║
                ╚══════════════════════════════╝


    Можно заметить, что сегмент памяти стек во многом похож на стек из теории алгоритмов, 
    только применимым к задачи управления памяти.


    Задача:

        Запустите эту программу и посмотрите чему равны адреса переменных на стеке.
        
        1)  Убедитесь в том, что адреса переменных вложенных функций имеют меньшее значение на вашей системе.
            То есть в том, что стек растёт сверху вниз.

        2)  Убедитесь в том, что память функции funcc, при втором вызове, будет занимать то же место,
            что раньше занимала память функции funcb.
*/