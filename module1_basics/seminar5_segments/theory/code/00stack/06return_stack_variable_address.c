/*
    UB при возврате указателя на локальный объект

    Одна из ошибок, которая может произойти при работе со стеком, это возврат из функции указателя,
    который указывает на локальную переменную в функции.

    Память под все локальные переменные функции выделяется на стеке при вызове функции и удаляется при завершении функции. 
    Если же мы вернём из функции указатель, который будет хранить адрес локальной переменной функции, то,
    после завершения функции, он будет указывать на уже удалённый объект.
    Разыменовывание и использование этого указателя приведёт к ошибке - неопределённому поведению (UB).
    Указатели, которые указывают на уже удалённые объекты называются висячими (англ. dangling pointer).
*/

#include <stdio.h>

int* func()
{
    int a = 123;
    int* p = &a;
    return p;
}

int main()
{
    int* p = func();

    printf("%i\n", *p);  // UB
}

/*
    Рассмотрим этот пример подробнее.


    1)  В функции main мы входим в функцию func.

    2)  В функции func мы создаём два объекта: целое a типа int и указатель p, хранящий адрес a.
        Память под эти объекты выделяется при вызове функции.

    3)  После этого мы выходим из функции func и возвращаем указатель p. Этот указатель копируется в указатель p функции main.
        Получается, что указатель p функции main указывает на память в которой раньше хранилась переменная a функции func.
        Но после завершения функции func, объект a удалился, соответственно указатель p является висячим.

    4)  Мы разыменовываем этот указатель и печатаем то, на что он указвает. Это ошибка - неопределённое поведение.
        При этом, есть вероятность того, что в этом случае программа всё-таки напечатает число 123 на экран.
        Но это только потому что память в которой раньше хранился объект a ещё не была использована какой-либо
        другой функцией и не была затёрта. Если бы мы между двумя строка в функции main вызвали бы какую-нибудь
        другую функцию, то эта память бы затёрлась и на экран напечаталось бы что-то другое.
*/