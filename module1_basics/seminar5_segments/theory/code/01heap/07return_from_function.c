/*
    Возврат массива из функции, используя выделение памяти в куче.

    Допустим мы хотим создать функцию, которая должна будет возвращать массив. Как это можно сделать?
    Просто так вернуть массив из функции не получится, функция не может вернуть массив.
    Рассмотрим следуещие 3 способа:


    1)  Возврат массива, созданого на стеке (Ошибка)
    
        Известно, что при передаче массива в функцию он всегда передаётся по указателю. 
        Можно попытаться создать статический массив внутри функции и вернуть указатель на него:

            int* get_primes_stack()
            {
                int primes[5] = {2, 3, 5, 7, 11};
                return (int*)primes;
            }

        Однако это является грубой ошибкой.
        Дело в том, что память на стеке выделяется в начале выполнения функции и освобождается по выходу из функции. 
        Таким образом, возвращаемый указатель будет ссылаться на уже освобождённую память. Ошибка!


    2)  "Возврат" массива, через аргумент функции (Рабочий способ)

        Другой способ "возврата"" массива: передадим функции указатель на уже созданный массив и попросим его заполнить. 
        При этом нужно следить, чтобы функция не вышла за пределы массива. Так мы передавали массивы в функции в предыдущих семинарах.

            void get_primes_argument(int* primes)
            {
                primes[0] = 2;
                primes[1] = 3;
                primes[2] = 5;
                primes[3] = 7;
                primes[4] = 11;
            }


    3)  Возврат массива, созданого в куче (Рабочий способ)

        Наконец, ещё один, новый способ возврата массива из функции – это создание массива в куче с помощью malloc
        и возвращение указателя на него. При завершении функции, выделенная в куче память не освобождается и этот
        массив можно использовать. 

            int* get_primes_heap()
            {
                int* p = malloc(sizeof(int) * 5);
                p[0] = 2;
                p[1] = 3;
                p[2] = 5;
                p[3] = 7;
                p[4] = 11;
                return p;
            }

        Только нужно не забыть вызвать free, когда массив станет не нужен.
        Помните, на каждый malloc должен приходиться один и только один вызов free.
        Так как внутри функции get_primes_heap мы free не вызывали (потомы что массив нам будет нужен и после
        завершения функции), то нам придётся вызвать free уже в другой функции.
*/

#include <stdlib.h>
#include <stdio.h>


// Эта функция содержит ошибку
int* get_primes_stack()
{
    int primes[5] = {2, 3, 5, 7, 11};
    int* p = &primes[0];
    return p;
}


void get_primes_argument(int* primes)
{
    primes[0] = 2;
    primes[1] = 3;
    primes[2] = 5;
    primes[3] = 7;
    primes[4] = 11;
}


int* get_primes_heap()
{
    int* p = (int*)malloc(sizeof(int) * 5);
    p[0] = 2;
    p[1] = 3;
    p[2] = 5;
    p[3] = 7;
    p[4] = 11;
    return p;
}


void print_array(int* array, size_t n)
{
    for (size_t i = 0; i < n; ++i)
        printf("%i ", array[i]);
    printf("\n");
}


int main()
{
    // int* p1 = get_primes_stack();
    // print_array(p1, 5);


    int a2[5];
    get_primes_argument(a2);
    print_array(a2, 5);


    int* p3 = get_primes_heap();
    print_array(p3, 5);
    free(p3);
}

/*
    Задача:

        Напишите функцию int* get_arithmetic(int start, int d, int n), которая будет оздавать в куче массив, 
        размером в n элементов типа int и задавать его арфметической прогрессией:

            start, start + d, start + 2 * d, ... start + (n - 1) * d
        
        Функция должна возвращать указатель на этот динамический массив в куче.
*/