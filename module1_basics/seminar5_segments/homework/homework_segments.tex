\documentclass[10pt]{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage[left=2cm, right=2cm, top=1.5cm, bottom=1.5cm]{geometry}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{colortbl}
\usepackage{graphicx}
\usepackage[shortlabels]{enumitem}
\usepackage{hyperref}
\pagenumbering{gobble}

\lstdefinestyle{CStyle}{
  language=C,
  basicstyle=\linespread{1.1}\ttfamily,
  basewidth=0.5em,
  texcl=true,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  backgroundcolor=\color{white},
  breaklines=true,
  breakatwhitespace=true,
  xleftmargin=5mm,
  keepspaces = true,
  extendedchars=\true,
  tabsize=4,
  upquote=true,
  emph={size_t, NULL},
  emphstyle={\color{blue}\bfseries},
}
\lstdefinestyle{boxStyle}{
  style=CStyle,
  framexleftmargin=5mm, 
  frame=shadowbox, 
  rulesepcolor=\color{gray}
}
\lstset{style=CStyle}

\renewcommand{\thesubsection}{\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\@ifundefined{#1@cntformat}%
   {\csname the#1\endcsname\quad}
   {\csname #1@cntformat\endcsname}}
\newcommand\section@cntformat{}
\newcommand\subsection@cntformat{Задача \thesubsection.\space}
\newcommand\subsubsection@cntformat{\thesubsubsection.\space}
\makeatother

\newcommand{\mallocImagesScale}{0.72}

\begin{document}

\title{Семинар \#5: Сегменты памяти. Домашнее задание.\vspace{-5ex}}\date{}\maketitle
\subsection{Создание объектов в куче}

Напишите код, который будет создавать в куче объекты, соответствующие следующим рисункам. В каждой задаче напечатайте созданные в куче объекты. В каждой задаче освободите всю память, которую вы выделили.
\begin{enumerate}
\item Одно число типа \texttt{size\_t}.
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/00heap_size_t.png}
\end{center}


\item Строка (массив из элементов типа \texttt{char}).
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/01heap_char_array.png}
\end{center}

\item Указатель, указывающий на строку.
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/02heap_pointer_char_array.png}
\end{center}


\item Структура типа \texttt{Book} из семинара про структуры. Для печати такой структуры можете использовать функцию \texttt{print\_book} из семинара про структуры.
\begin{lstlisting}
struct book 
{
    char title[50];
    int pages;
    float price;
};
typedef struct book Book;
\end{lstlisting}
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/03heap_struct_book.png}
\end{center}

\newpage
\item Указатель, указывающий на структуру на стеке.
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/04heap_pointer_stack_struct_book.png}
\end{center}


\item Указатель, указывающий на структуру в куче.
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/05heap_pointer_struct_book.png}
\end{center}


\item Массив структур.
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/06heap_struct_book_array.png}
\end{center}

\item Видоизмените структуру \texttt{Book}, чтобы она, вместо строки, хранила указатель на строку в куче. Таким образом у нас не будет ограничения на длину названия. Создайте такую структуру в куче. Функцию \texttt{print\_book} для такой структуры потребуется немного изменить.
\begin{lstlisting}
struct book 
{
    char* title;
    int pages;
    float price;
};
typedef struct book Book;
\end{lstlisting}

\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/07heap_struct_book_title_heap.png}
\end{center}

\iffalse
\item Массив таких структур в куче.
\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/08heap_array_struct_book_title_heap.png}
\end{center}
\fi

\item Создадим структуру \texttt{Library}, которая сможет хранить информацию о произвольном количестве книг.
\begin{lstlisting}
struct library 
{
    Book* books;
    int number_of_books;
};
typedef struct library Library;
\end{lstlisting}

\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/09stack_struct_book_library.png}
\end{center}

Напишите функции для удобной работы с такой структурой:
\begin{itemize}
\item \texttt{library\_create} - функция должна задавать поля \texttt{books} и \texttt{number\_of\_books} структуры \texttt{Library}. При этом данная функция должна выделять необходимое количество памяти.
\item \texttt{library\_set} - должна задавать значение \texttt{i}-й книги.
\item \texttt{library\_get} - принимает на вход индекс \texttt{i} и возвращает указатель на \texttt{i}-ю книгу.
\item \texttt{library\_print} - должна печатать все книги библиотеки на экран.
\item \texttt{library\_destroy} - должна освобождать всю память и устанавливать значения полей в \texttt{NULL} и \texttt{0} соответственно.
\end{itemize}
\begin{lstlisting}
Library a;
library_create(&a, 3);
library_set(a, 0, "Don Quixote", 1000, 750.0);
library_set(a, 1, "Oblomov", 400, 250.0);
library_set(a, 2, "The Odyssey", 500, 500.0);
library_print(a);
print_book(library_get(a, 1));
library_destroy(&a);
\end{lstlisting}

Обратите внимание, что функции \texttt{library\_create} и \texttt{library\_destroy} должны принимать указатель на структуру \texttt{Library} так как они должны менять поля этой структуры.


\iffalse
\item Изменим структуру \texttt{Library} так, чтобы она хранила указатель на массив из указателей на структуры.
\begin{lstlisting}
struct library 
{
    Book** books;
    int number_of_books;
};
typedef struct library Library;
\end{lstlisting}

\begin{center}
\includegraphics[scale=\mallocImagesScale]{../images/malloc_homework/11stack_struct_book_library.png}
\end{center}


Напишите функции для удобной работы с такой структурой:
\begin{itemize}
\item \texttt{library\_create} - функция должна задавать поля \texttt{books} и \texttt{number\_of\_books} структуры \texttt{Library}. При этом данная функция должна выделять память под массив из указателей и задавать все значения элементов массива значением \texttt{NULL}.
\item \texttt{library\_set} - должна задавать значение \texttt{i}-й книги.
\item \texttt{library\_get} - принимает на вход индекс \texttt{i} и возвращает указатель на \texttt{i}-ю книгу. Если структура с таким индексом ещё не создана, то функция должна вернуть \texttt{NULL}.
\item \texttt{library\_print} - должна печатать все книги библиотеки на экран.
\item \texttt{library\_destroy} - должна освобождать всю память (память под структуры и память под массив указателей) и устанавливать значения полей в \texttt{NULL} и \texttt{0} соответственно.
\end{itemize}

Работа с такой структурой не должна отличаться от работы со структурой из предыдущей подзадачи:
\begin{lstlisting}
Library a;
library_create(&a, 3);
library_set(a, 0, "Don Quixote", 1000, 750.0);
library_set(a, 1, "Oblomov", 400, 250.0);
library_set(a, 2, "The Odyssey", 500, 500.0);
library_print(a);
print_book(library_get(a, 1));
library_destroy(&a);
\end{lstlisting}
\fi
\end{enumerate}




\subsection{Геометрическая прогрессия}
Напишите функцию \texttt{float* get\_geometric\_progression(float a, float r, int n)}, которая возвращает указатель на массив в куче, содержащий геометрическую прогрессию из $n$ чисел: 
$a, ar, ar^2, ...$ 
Память должна выделяться динамически. Вызовите эту функцию из \texttt{main} и напечатайте первые 10 степеней тройки.

\subsection{Конкатенация с выделением памяти}
Напишите функцию \texttt{char* concat(const char* a, const char* b)}, которая принимает на вход две строки и возвращает новую строку, являющуюся конкатенацией первых двух. Память под новую строку функция должна выделять в куче.




\newpage
\subsection{Сортировщик строк}
Динамический массив строк -- это двумерный динамический массив элементов типа \texttt{char}. 
Но с одной особенностью: размер строки задаётся не числом в отдельной переменной, а специальным нулевым символом на конце строки. Поэтому мы можем не хранить размер каждой строки. \\
Мы можем хранить количество строк в таком массиве в отдельной переменной, а можем просто выделить в массиве указателей на один элемент больше и хранить в этом элементе значение \texttt{NULL}. Таким образом мы можем найти количество строк в массиве.\\


\begin{center}
\includegraphics[scale=0.8]{../images/malloc_homework/12string_array_heap.png}
\end{center}

\begin{enumerate}
\item Написать функцию \texttt{char** get\_test\_strings()} который будет создавать массив строк, представленный на рисунке выше, и возвращать его.

\item Написать функцию \texttt{void print\_strings(const char** string\_array)} который будет печатать переданный массив строк \texttt{string\_array}.

\item Написать функцию \texttt{size\_t* get\_sizes(const char** string\_array)} которая будет возвращать массив, содержащий размеры всех строк. Память под этот массив должна выделяться в куче.

\item Написать функцию \texttt{char** load\_lines(const char* filename)},
которая будет создавать динамический массив строк, считывать из файла все строки в этот массив строк, и возвращать его. Один из способов как это можно сделать:
\begin{itemize}
\item Пройдите по файлу с помощью \texttt{fgetc} и посчитайте количество строк в файле (количество \texttt{\textbackslash n} + 1).
\item Выделите необходимую память в куче под массив указателей (учтите нулевой указатель в конце).
\item Вернитесь в начало файла с помощью \texttt{fseek}.
\item Пройдите файл заново, подсчитайте количество символов в каждой строке и сохраните эти данные во временном массиве в куче.
\item Выделите необходимую память для каждой строки (учтите нулевой символ в конце строк).
\item Вернитесь в начало файла с помощью \texttt{fseek}.
\item Пройдите файл заново, считайте и запишите каждую строку в свой элемент массива.
\item Освободите память под временный массив, закройте файл и верните результат.
\end{itemize}
Это не совсем оптимальный способ, так как приходится 3 раза проходить по файлу. Если есть желание, можно написать более оптимальный алгоритм с использованием \texttt{realloc} и \texttt{fgets}.
\item Написать функцию \texttt{void destroy\_strings(char*** p\_string\_array)}, которая будет уничтожать динамический массив строк. Эта функция должна освобождать всю память (память под каждую строку и память под массив указателей). Также эта функция должна присваивать указателю \texttt{p} значение \texttt{NULL}.
\begin{lstlisting}
char** p = load_lines("three_little_pigs.txt");
destroy_strings(&p);
\end{lstlisting}

\item Написать функцию \texttt{void sort\_strings(char** words)}, которая будет сортировать все строки по алфавиту. Используйте функцию \texttt{strcmp}.

\item Напишите программу \texttt{line\_sorter}, которая будет считывать текстовый файл, сортировать строки этого файла по алфавиту и записывать результат в другой файл. Названия файлов функция должна принимать через аргументы командной строки.
Пример использования такой программы:
\begin{lstlisting}
$ ./line_sorter invisible_man.txt result.txt
\end{lstlisting}
\end{enumerate}


\subsection{Разные сегменты}
В следующей программе на экран печатаются адреса различных объектов, созданных в программе.
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int a;
int b = 10;
const int c = 20;
void f() 
{
    printf("hello f\n");
}
int main()
{
    int d;
    static int e; 
       
    int* pi = (int*)malloc(sizeof(int) * 10);
    
    const char s[] = "cat";
    const char* ps = "dog";
    
    printf("&a   = %p\n", &a);
    printf("&b   = %p\n", &b);
    printf("&c   = %p\n", &c);
    printf("&d   = %p\n", &d);
    printf("&e   = %p\n", &e);
    printf("&pi  = %p\n", &pi);
    printf("pi   = %p\n", pi);
    printf("pi+5 = %p\n", pi + 5);
    printf("&s   = %p\n", &s);
    printf("s    = %p\n", s);
    printf("&ps  = %p\n", &ps);
    printf("ps   = %p\n", ps);
    printf("f    = %p\n", f);
    printf("&f   = %p\n", &f);
    printf("main   = %p\n", main);
    printf("\"fox\"  = %p\n", "fox");
    
    free(pi);
}
\end{lstlisting}
Нужно определить к какому сегменту соответствует каждый из печатаемых адресов. Варианты следующие: \texttt{stack}, \texttt{heap}, \texttt{text}, \texttt{data}, \texttt{rodata} и \texttt{bss}. Чтобы сдать эту задачу нужно создать файл в формате \texttt{.txt} и, используя любой текстовый редактор, записать в него ответы в следующем формате (ответы ниже неверны):
\begin{lstlisting}
&a - stack
&b - heap
&c - text
&d - data
&pi - rodata
pi - bss
...
\end{lstlisting}
После этого, файл нужно поместить в ваш репозиторий на github.






\subsection{Сортировка с компараторами}
Простой алгоритм сортировки, называемый сортировка выбором, можно написать следующим образом:
\begin{lstlisting}
void sort(int* a, size_t n)
{
    for (size_t j = 0; j < n; ++j)
    {
        size_t min_index = j;
        for (size_t i = j + 1; i < n; ++i)
        {
            if (a[i] < a[min_index])
                min_index = i;
        }

        int temp = a[j];
        a[j] = a[min_index];
        a[min_index] = temp;
    }
}
\end{lstlisting}
Но эта функция сортирует числа только по возрастанию. Нужно изменить эту функцию так, чтобы она принимала на вход третий аргумент -- компаратор. Компаратор должен представлять собой указатель на функцию типа:
\begin{lstlisting}
int (*)(int a, int b)
\end{lstlisting}
Использование новой функции с компаратором должно выглядеть так:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

void print(int* a, size_t n)
{
    for (size_t i = 0; i < 6; ++i)
        printf("%i ", a[i]);
    printf("\n");
}
// Тут нужно написать новую функцию sort и функции - компараторы: 
//     less            - сортировка по возрастанию
//     greater         - по убыванию
//     last\_digit\_less - по возрастанию последней цифры

int main()
{
    int a[] = {32, 63, 29, 54, 81};
    
    sort(a, 5, less);
    print(a, 5); // Должен напечатать 29 32 54 63 81 
        
    sort(a, 5, greater);
    print(a, 5); // Должен напечатать 81 63 54 32 29
    
    sort(a, 5, last_digit_less);
    print(a, 5); // Должен напечатать 81 32 63 54 29
}
\end{lstlisting}


\subsection{Подсчёт с помощью предиката}
Напишите функцию \texttt{count\_if}, которая будет подсчитывать сколько элементов в массиве удовлетворяют какому-либо условию. Условие должно задаваться путём передачи в функцию \texttt{count\_if} указателя на другую функцию -- так называемую функцию-предикат.

\begin{lstlisting}
#include <stdio.h>
// Тут нужно написать функцию count\_if и функции - предикаты:
//     is\_negative  - проверяет, является ли число отрицательным
//     is\_even      - проверяет, является ли число чётным
//     is\_square    - проверяет, является ли число квадратом целого числа

int main()
{
    int a[] = {89, 81, 28, 52, 44, 16, -64, 49, 52, -79};
    
    printf("%zu\n", count_if(a, 10, is_negative));  // Должен напечатать 2
    printf("%zu\n", count_if(a, 10, is_even));      // Должен напечатать 6
    printf("%zu\n", count_if(a, 10, is_square));    // Должен напечатать 3
}

\end{lstlisting}


\iffalse
\subsection{Сортировка функций}
Пусть есть следующая программа:
\begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>

int sum(int x, int y)
{
    printf("I am sum\n");
    return x + y;
}

int diff(int x, int y)
{
    printf("I am diff\n");
    return x - y;
}

int mult(int x, int y)
{
    printf("I am mult\n");
    return x * y;
}

int sqdiff(int x, int y)
{
    printf("I am sqdiff\n");
    return x * x - y * y;
}

int lin(int x, int y)
{
    printf("I am lin\n");
    return 5 * x - y;
}

typedef int (*Func)(int, int);

Func array[4] = {sum, diff, mult, lin};


void call_functions(Func* array, size_t n);
void sort_functions(Func* array, size_t n, int x, int y);

int main()
{    
    call_functions(array, 4);
    sort_functions(array, 4, 2, 2);
    call_functions(array, 4);
    sort_functions(array, 4, 8, 1);
    call_functions(array, 4);
}
\end{lstlisting}

\begin{itemize}
\item Напишите функцию \texttt{call\_functions}, которая будет вызывать функции с аргументами \texttt{x = 0} и \texttt{y = 0}.
\item Напишите функцию \texttt{sort\_functions}, которая будет сортировать функции в массиве \texttt{array} по возрастанию возвращаемого значения при аргументах \texttt{x} и \texttt{y}.
\end{itemize}
\fi


\subsection{Сумматор}
Создайте функцию \texttt{adder}, которая будет принимать на вход число и возвращать сумму всех чисел, которые приходили на вход этой функции за время выполнения программы.
\begin{lstlisting}
#include <stdio.h>
// Тут нужно написать функцию adder

int main()
{
    printf("%i\n", adder(10));  // Должен напечатать 10
    printf("%i\n", adder(15));  // Должен напечатать 25
    printf("%i\n", adder(70));  // Должен напечатать 95
}
\end{lstlisting}

\subsection{Когда выделяется память}
В следующей программе выделяется $10^9$ байт в сегменте памяти BSS. Программа "видит"{} весь массив как доступный с начала выполнения. Но операционная система может сэкономить ресурсы и не выделять память сразу. Рассмотрим следующую программу:
\begin{lstlisting}
#include <stdio.h>

#define SIZE 1'000'000'000
char data[SIZE];

int main()
{
    getchar();
    printf("1. Setting first char to 'A'\n");
    data[0] = 'A';
    
    getchar();
    printf("Setting last char to 'B'\n");
    data[SIZE - 1] = 'B';
    
    getchar();
    printf("Printing first char = %c\n", data[0]);
    
    getchar();
    printf("Printing last char = %c\n", data[SIZE - 1]);
    
    getchar();
    printf("Setting many chars to X\n");
    for (size_t i = 0; i < SIZE; i += 1000)
        data[i] = 'X';
        
    getchar();
    printf("Printing all set chars\n");
    for (size_t i = 0; i < SIZE; i += 1000)
        printf("%c ", data[i]);
        
    getchar();
}
\end{lstlisting}

\begin{enumerate}[a.]
\item Определить на каком шаге операционная система действительно выделяет ресурсы. Для того, чтобы сдать эту подзадачу, создайте файл \texttt{09a.txt} и опишите в нём на каком шаге происходит выделение памяти.
\item Перепишите программу так, чтобы память выделялась в куче и проверьте когда память будет выделяться в этом случае.Для того, чтобы сдать эту подзадачу, создайте файлы \texttt{09b.c}, в котором будет переписанная программа и файл \texttt{09b.txt} в котором будет описана на каком этапе будет на самом деле выделяться память в этом случае.
\item Перепишите программу так, чтобы память выделялась на стеке и проверьте что будет происходить в этом случае. Объясните поведение программы в файле \texttt{09c.txt}.
\end{enumerate}
После этого, файлы нужно поместить в ваш репозиторий на github.


\end{document}
