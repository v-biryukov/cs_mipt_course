/*
    Работа с памятью



    По сути, во время своей работы программа так или иначе работает с памятью.
    Расмотрим простейший пример. Если мы создаём переменную типа int вот так:

        int x = 123456;

    То это означает, что в памяти выделится  sizeof(int)  байт, а значения этих байт зададутся таким образом,
    чтобы в них кодировалось значение 123456.

    Если мы работаем на системе, где переменные типа int имеют размер в 4 байта, то участок памяти, где хранится x может
    выглядеть так (123456 в десятичной это 1e240 в шестнадцатеричной):

                    |         x         |
            ═══╤════╤════╤════╤════╤════╤════╤═══
               │    │ 00 │ 01 │ e2 │ 40 │    │   
            ═══╧════╧════╧════╧════╧════╧════╧═══

    Таким образом, простое создание переменной и задание её значение изменяет байты памяти.


    

    Но что, если мы хотим работать с участком памяти размером в n байт и иметь возможность задавать значение каждого байта?
    
    Мы могли бы создать массив элементов типа int размера n / 4 байт.
    Это можно сделать, но это неудобно. Так как в этом случае можно было бы работать только с куском памяти 
    размера кратным 4-м байт. А также было бы неудобно задавать значение каждого конкретного байта.

    Поэтому лучшее решение - это создать массив размера n из элементов размером в 1 байт.
    Подойдут следующие типы для элементов: char, unsigned char, int8_t, uint8_t.
    Так как гарантированно, что все эти типы будут иметь размер в 1 байт на любой системе.


    Удобнее использовать беззнаковое однобайтовое число, так как в этом случае значение каждого байта 
    можно задавать числом от 0 до 255 (или от 0x00 до 0xff в шестнадцатеричной системе).
    Тогда как для знакового однобайтового числа пришлось бы использовать диапазон от -128 до 127 (от -0x80 до 0x7F).
    Остаются типы unsigned char и uint8_t. В этом курсе мы будем использовать тип unsigned char.


    Таким образом, если мы, например, хотим работать с куском памяти, размеров в 5 байт, то нам нужно создать такой массив:

        unsigned char a[5];

    Каждый отдельный байт удобно задавать, используя шестнадцатеричные числа.
    Например, зададим 4-й байт значением 0xff:

        a[3] = 0xff;


    Для считывания/печати однобайтовых беззнаковых чисел нужно использовать спецификаторы:
    
        %hhu - считывание/печать однобайтовых беззнаковых чисел в десятичной системе
        %hhx - считывание/печать однобайтовых беззнаковых чисел в шестнадцатеричной системе
    
*/

#include <stdio.h>


int main()
{
    unsigned char a[5] = {0x1a, 0x3b, 0x5c, 0x7d, 0x9e};

    a[3] = 0xff;


    for (size_t i = 0; i < 5; ++i)
    {
        printf("%hhx ", a[i]);
    }
    printf("\n");


    for (size_t i = 0; i < 5; ++i)
    {
        printf("%hhX ", a[i]);
    }
    printf("\n");


    for (size_t i = 0; i < 5; ++i)
    {
        printf("%hhu ", a[i]);
    }
    printf("\n");
}



/*
    Задача:

        Создайте массив размером в 256 байт и задайте его байты значениями от 0x00 до 0xff в порядке возрастания.
        Напечатайте этот массив на экран побайтово. Каждый байт напечатайте в шестнадцатеричной системе счислений.
*/