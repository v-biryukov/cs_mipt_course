/*
    Функция memcpy и пересекающиеся диапазоны


    Функция memcpy может работать некоректно, если кусок памяти откуда производится копирование и
    кусок памяти куда производится копирование пересекаются.



    Например, в данном примере у нас есть массив a из 10-ти элементов, заданные следующим образом:
    
        01 02 03 04 05 06 07 08 09 0a

    Функция memcpy вызывается вот так:

        memcpy(a + 3, a, 6);

    Это означает, что мы копируем 6 элементов из области памяти, начинающейся с первого элемента массива 
    в область памяти, начинающуюся с четвертого элемента массива.
    После такого копирования массив должен выглядеть следующим образом:

        01 02 03 01 02 03 04 05 06 0a

    Однако, в данном случае, функция memcpy может отработать некорректно и, например, выдать такой результат:

        01 02 03 01 02 03 01 02 03 0a



    Как конкретно отработает функция memcpy на пересекающихся кусках памяти зависит от того как она реализована 
    в вашей стандартной библиотеке. Есть вероятность, что у вас функция отработает корректно, но на какой-то другой
    системе она будет работать неправильно.
    
    !!  Поэтому использование memcpy на пересекающихся кусках памяти считается неопределённым поведением.
*/

#include <stdio.h>
#include <string.h>

#define SIZE ((size_t)10)

int main()
{
    unsigned char a[SIZE];

    for (size_t i = 0; i < SIZE; ++i)
    {
        a[i] =  (i + 1);
    }


    for (size_t i = 0; i < SIZE; ++i)
    {
        printf("%02hhx ", a[i]);
    }
    printf("\n");



    memcpy(a + 3, a, 6);



    for (size_t i = 0; i < SIZE; ++i)
    {
        printf("%02hhx ", a[i]);
    }
    printf("\n");
}
