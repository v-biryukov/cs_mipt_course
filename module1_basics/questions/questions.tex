\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}


\begin{document}
\pagenumbering{gobble}

\section*{Теория:}

\section*{Модуль 1}
\begin{enumerate}
\item \textbf{Переменные, операторы и массивы}

\begin{enumerate}[a.]
\item \textbf{Основные команды командной строки}\\
\texttt{cd}, \texttt{ls} (опции \texttt{-l} и \texttt{-a}), \texttt{pwd}, \texttt{cp}, \texttt{mv}, \texttt{rm} (опция \texttt{-r}), \texttt{mkdir}, программа \texttt{top}, компилятор \texttt{gcc} (опции \texttt{-o}, \texttt{-std=c99} и \texttt{-std=c23}). Перенаправление вывода \texttt{>}. Возвращаемое значение функции \texttt{main}. Функция \texttt{exit} из библиотеки \texttt{stdlib.h}.

\item \textbf{Стандартный ввод/вывод}\\
Ввод и вывод в языке C. Функции \texttt{printf} и \texttt{scanf} из библиотеки \texttt{stdio.h}.
Что делают следующие спецификаторы: \texttt{\%i}, \texttt{\%2i}, \texttt{\%02i}, \texttt{\%p}. 

\item \textbf{Переменные}\\
Что такое переменные? Переменные типа \texttt{int}. Инициализация переменных. Инициализация переменных. Чем инициализируются локальные переменные по умолчанию? Инициализация и присваивание, в чём различие между ними. Размер переменной типа \texttt{int}. Максимальное и минимальное значение для переменных типа \texttt{int}. 

\item \textbf{Операторы}\\
Арифметические операторы(\texttt{+ - * / \%}). Что делает оператор деления, если аргументы целочисленные и если аргументы -- числа с плавающей точкой? Оператор присваивания (\texttt{=}). Оператор присваивания сложения и подобные ему (\texttt{+= -= *= /= \%=}). Операторы инкремента и декремента (\texttt{++  $--$}). Префиксный  и постфиксный инкремент/декремент, чем они отличаются. Операторы сравнения (\texttt{== != > < >= <=}). Что возвращают операторы сравнения? Логические операторы (\texttt{!  ||  \&\&}). Оператор нахождения адреса (\texttt{\&}). Оператор нахождения размера переменной (\texttt{sizeof}). Приоритет операторов.

\item \textbf{Ветвление и циклы}\\
Оператор ветвления \texttt{if-else}. Использования логических операторов в условии оператора ветвления.  Цикл \texttt{while}. Цикл \texttt{for}. Цикл \texttt{do while}. Операторы \texttt{break} и \texttt{continue}.

\item \textbf{Создание и инициализация массивов}\\
Массивы. Элемент массива и индекс массива. Как хранятся массивы в памяти? Объявление и определение массивов. Инициализация массивов. Можно ли присваивать массив другому массиву с помощью оператора присваивания? Как распечатать массив? Размер массивов. Как узнать размер массива, используя оператор \texttt{sizeof}?

\item \textbf{Двумерные массивы}\\
Объявление, определение и инициализация двумерного массива. Как двумерный массив хранится в памяти?

\item \textbf{Виды ошибок}\\
Ошибки компиляции. Ошибки линковки. Ошибки времени выполнения. Логические ошибки. Неопределённое поведение.
\end{enumerate}


\item \textbf{Функции и типы данных}

\begin{enumerate}[a.]
\item \textbf{Основы работы с функциями}\\
Параметры и аргументы функции. Возвращаемое значение функции. Объявления функции. Прототип функции. Определение функции.
Возврат из функции. Ключевое слово \texttt{return}. Ключевое слово \texttt{void}.

\item \textbf{Передача в функцию}\\
Как переменные базовых типов и структуры передаются в функции? Как массивы передаюся в функции? Три типа передачи аргументов в функцию: по значению, через указатель, через константный указатель. Передача одномерных и многомерных массивов в функции.

\item \textbf{Рекурсия}\\
Рекурсия. Алгоритмы вычисления факториала и алгоритм вычисления чисел Фибоначчи. 

\item \textbf{Целочисленные типы данных}\\
Типы целочисленных переменных: \texttt{char}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{long long} и их \texttt{unsigned}-аналоги. Типичные размеры этих типов на современных системах и диапазоны значений, которые могут принимать данные типы. Создание новых названий для типов с помощью ключевого слова \texttt{typedef}. Что такое тип \texttt{size\_t}. Когда он используется? Типы фиксированной ширины: \texttt{int8\_t}, \texttt{uint8\_t}, \texttt{int16\_t} и другие. Целочисленное переполнение. Неопределённое поведение при целочисленном переполнении.

\item \textbf{Константы}\\
Квалификатор типа \texttt{const}. Разница между определение константы с помощью директивы \texttt{\#define} и квалификатора \texttt{const}.

\item \textbf{Типы чисел с плавающей точкой}\\
Типы чисел с плавающей точкой: \texttt{float}, \texttt{double}. Типичные размеры этих типов на современных системах и диапазоны значений, которые могут принимать данные типы.

\item \textbf{Приведение типов.}\\
Неявное приведение типов. Когда оно происходит? Явное приведение типов. Как привести один тип в другой?

\item \textbf{Математическая библиотека \texttt{math.h}}\\
Функции \texttt{sqrt}, \texttt{exp}, \texttt{sin}, \texttt{cos}, \texttt{tan}, \texttt{asin}, \texttt{acos}, \texttt{atan}, \texttt{atan2}, \texttt{fabs}, \texttt{floor}, \texttt{log}, \texttt{pow}. Сравнение двух чисел с плавающей точкой с помощью функции \texttt{fabs}.
\end{enumerate}



\item \textbf{Строки и текстовые файлы}
\begin{enumerate}[a.]
\item \textbf{Символы}\\
Кодировка ASCII. Использование целочисленного типа \texttt{char} для хранения кодов символов. Чтение и запись символов (спецификатор \texttt{\%с}). Символьные литералы. Библиотека \texttt{ctype.h}. Функции \texttt{isalpha}, \texttt{isdigit}. Какие символы называются пробельными? Функция \texttt{isspace}. Функции \texttt{toupper} и \texttt{tolower}.

\item \textbf{Строки в языке C}\\
Что такое строка в языке C? Как строки хранятся в языке C. Символ завершения строки. Чтение и запись строк (спецификатор \texttt{\%s}).

\item \textbf{Библиотека \texttt{string.h}}\\
Функции \texttt{strlen}, \texttt{strcpy}, \texttt{strcmp}. Функции \texttt{sprintf} и \texttt{sscanf}, использование этих функций для конвертации числа в строку и наоборот. Почему функция \texttt{strcpy} считается небезопасной?

\item \textbf{Аргументы командной строки}\\
Аргументы функции \texttt{main}: \texttt{argc} и \texttt{argv}. Что они означают и как их использовать?

\item \textbf{Текстовые файлы}\\
Открытие и закрытие файла, функции \texttt{fopen} и \texttt{fclose}. Режимы открытия файла \texttt{"w"} и \texttt{"r"}.
Запись/чтение с помощью функций \texttt{fprintf} и \texttt{fscanf}. Запись/чтение по одному байту с помощью функций \texttt{fputc} и \texttt{fgetc}. Объект какого типа возвращает функция \texttt{fgetc} и почему? Что функция \texttt{fgetc} возращает при достижении конца файла? Глобальные потоки \texttt{stdin} и \texttt{stdout}.
\end{enumerate}





\item \textbf{Указатели и структуры}
\begin{enumerate}[a.]
\item \textbf{Указатели}\\
Что хранят указатели? Объявление указателя. Инициализация указателя. Размер указателя на 32-х и 64-х битных системах. Операция нахождения адреса (\texttt{\&}) переменной. Операция разыменования \texttt{*} указателя.

\item \textbf{Арифметика указателей}\\
Операторы, применимые ко всем указателям: оператор разыменования, операторы проверки на равенство/неравенство. Операторы, применимые к указателям, указывающим на элемент массива: \texttt{++}, \texttt{--}, прибавление/вычитание целого числа, вычитание двух указателей, оператор индексирования. Связь оператора индексирования (\texttt{[]}) с оператором разыменования. Когда использование этих операторов приводит к ошибке?

\item \textbf{Указатели и функции}\\
Передача переменной в функцию по указателю. Возврат нескольких объектов из функции с помощью параметров-указателей.
Как передаётся массив в функцию? Array to pointer decay. Как передавать строки в функции. Как вернуть массив из функции?
Возврат указателя из функции. Висячие указатели.

\item \textbf{Указатели разных типов}\\
Чем различаются указатели разных типов? Приведение типов указателей. Указатель \texttt{void*}. Константный указатель (\texttt{const int* p}) и постоянный указатель (\texttt{int* const p}).

\item \textbf{Структуры}\\
Объявление структуры. Определение структуры. Инициализация структуры. Поля структуры. Операции применимые к структурам. Доступ к полю структуры. Оператор точка. Присваивание структур. Оператор присваивания. Массив структур. Инициализация массива структур. Использование ключевого слова \texttt{typedef} для создания более короткого имени для структуры.

\item \textbf{Указатели на структуры}\\
Доступ к полю по указателю на структуру. Оператор стрелочка \texttt{->}. 

\item \textbf{Передача структур в функции}\\
Три типа передачи в функции: передача по значению, передача по указателю и передача по константному указателю. В каких ситуациях нужно использовать тот или иной способ?
Возврат структур из функций.

\item \textbf{Выравнивание}\\
Размер структуры. Выравнивание полей структуры. Оператор \texttt{alignof}.
\end{enumerate}



\item \textbf{Сегменты}

\begin{enumerate}[a.]
\item \textbf{Сегменты памяти}\\
Что такое сегменты памяти? Ошибка Segmentation Fault.

\item \textbf{Сегмент памяти стек}\\
Сегмент памяти стек. Выделение и освобождение памяти в стеке. Размер стека. Реализация вызова функций с помощью сегмента памяти стек. Стековый кадр, что в нём хранится. Как можно переполнить стек? Переполнение стека при рекурсии.

\item \textbf{Сегмент памяти куча}\\
Динамическое выделение и освобождение памяти в куче: \texttt{malloc}, \texttt{realloc} и \texttt{free}. Преимущества и недостатки кучи перед стеком. Как обрабатывать случай, когда у \texttt{malloc} не получилось выделить запрашиваемое количество памяти? Утечки памяти. Программа \texttt{valgrind}. Повторное освобождение той же памяти. Возрат массива из функции с использованием выделения памяти в куче.

\item \textbf{Двумерный массив в сегменте куча}\\
Двумерный массив в сегменте куча. Два способа хранения такого массива: в виде одномерного массива и в виде массива указателей, каждый из которых будет указывать на соответсвующую строку массива.

\item \textbf{Сегмент памяти данные}\\
Сегменты памяти данные. Преимущества и недостатки сегмента данные перед стеком и кучей. Что такое глобальные переменные? Что такое статические переменные? Когда и как инициализируются глобальные и статические переменные? Строковые литералы. Где хранятся строковые литералы?

\item \textbf{Сегмент памяти Текст}\\
Сегмент памяти текст. Преобразование кода программы в код на языке ассемблера и в двоичный код. Указатели на функции. Объявление указателей на функции. Передача указателей на функции в другие функции. Стандартная функция \texttt{qsort} и передача в ней компаратора.
\end{enumerate}




\item \textbf{Динамический массив}

\begin{enumerate}[a.]
\item \textbf{Виды массивов в языке C}\\
Массив в сегменте стек. VLA-массив. Массив в сегменте данные. Массив в сегменте куча. Преемущества и недостатки создания каждого этих массивов.

\item \textbf{Создание своего динамического массива}\\
Создание своего динамического массива на основе массива в куче. Поля такого массива: указатель на данные в куче, размер (\texttt{size}) и вместимость (\texttt{capacity}). Чем размер отличается от вместимости? Функции для работы с нашим динимическим массивом:
\begin{itemize}
\item \texttt{init} -- инициализируем массив
\item \texttt{destroy} -- уничтожаем массив и освобождаем всю память
\item \texttt{get} -- возвращает \texttt{i}-й элемент
\item \texttt{set} -- устанавливаем \texttt{i}-й элемент
\item \texttt{reserve} -- изменяет вместимость динамического массива
\item \texttt{resize} -- изменяет размер динамического массива
\item \texttt{push\_back} -- добавляет один элемент в конец динамического массива
\item \texttt{pop\_back} -- удаляет последний элемент массива и возвращает его
\item \texttt{shrink\_to\_fit} -- делает вместимость массива равной её размеру
\end{itemize}
Поверхностная и глубокая копия динамического массива. 
Как изменить тип элемента, который хранится в динамическом массиве? 
Использование \texttt{typedef} для настроики типа элемента массива.

\item \textbf{Макросы-константы}\\
Директива препроцессора \texttt{\#define}. Создание констант с помощью макросов.
Условная компиляция.  Директивы препроцессора \texttt{\#if}, \texttt{\#ifdef}, \texttt{\#ifndef}, \texttt{\#else}, \texttt{\#elif}, \texttt{\#endif} и оператор \texttt{defined}. Флаг \texttt{-D} компилятора gcc. Предопределённые макросы:
\texttt{\_\_FILE\_\_}, \texttt{\_\_LINE\_\_}, \texttt{\_\_DATE\_\_}, \texttt{\_\_TIME\_\_}, \texttt{\_\_VERSION\_\_}, \texttt{\_\_cplusplus}. Макросы для определение операционной системы: \texttt{\_WIN32}, \texttt{\_WIN64}, \texttt{\_\_linux\_\_}, \texttt{\_\_APPLE\_\_}. 

\item \textbf{Заголовочные файлы}\\
Директива препроцессора \texttt{\#include} и что конкретно она делает. Header-файлы.
Стражи включения. \texttt{\#pragma once}.

\item \textbf{Функциональные макросы}\\
Функциональные макросы (function-like macros). Многострочные макросы. Типичные ошибки, которые могут возникнуть при работе с функциональными макросами. Использование оператора \texttt{do-while} в многострочных функциональных макросах. Операция stringification (\texttt{\#}). Операция concatenation (\texttt{\#\#}). Макрос \texttt{assert} из библиотеки \texttt{assert.h}. Написание макроса, аналогичного макросу \texttt{assert}. Флаг \texttt{-E} компилятора gcc.

\item \textbf{Макросы и динамический массив}\\
Использование макросов, для генерации кода динамического массива заданного типа.
\end{enumerate}


\item \textbf{Память и бинарные файлы}

\begin{enumerate}[a.]
\item \textbf{Шестнадцатеричная система счисления}\\
Шестнадцатеричная система счисления. Печать и считывания целочисленных переменных в шестнадцатеричной системе с помощью спецификатора \texttt{\%x}.

\item \textbf{Представление чисел в памяти}\\
Представление целых положительных чисел в памяти. Представление целых отрицательных чисел в памяти. Дополнительный код. Представление чисел с плавающей точкой в памяти с использованием стандарта IEEE 754.

\item \textbf{Побитовые операторы}\\
Побитовые операторы (\texttt{$\sim$  \&  |  \textasciicircum \quad <{}<  >{}>}). Побитовые операторы присваивания (\texttt{\&=  |=  \textasciicircum= \quad <{}<=  >{}>=}). Получение отрицательного числа и помощью побитовых операций. Изменение i-го бита числа с помощью побитовых операций. Печать всех битов числа.

\item \textbf{Память}\\
Порядок байт. Little endian и big endian. Просмотр байт объекта с помощью указателя типа \texttt{unsigned char*}. Функции \texttt{memset}, \texttt{memcpy}, \texttt{memmove} из стандартной библиотеки.

\item \texttt{* (необязательный вопрос)} \textbf{Алиасинг}\\
Что такое алиасинг? Strict Aliasing Rule. Неопределённое поведение при алиасинге. 


\item \texttt{* (необязательный вопрос)} \textbf{Бинарные файлы}\\
Бинарный и текстовый файл. Бинарный и текстовый режимы открытия файла. Как открыть файл в бинарном и текстовом режиме? В чём отличие бинарного и текстового режима в операционных системах Linux и Windows? Как хранится перенос строки в операционных системах Linux и Windows? Разница между CRLF и LF переносами строки. Запись из памяти в файл и чтение из файла в память с помощью функций \texttt{fwrite} и \texttt{fread}. Функции \texttt{fseek} и \texttt{ftell}. Использование функции \texttt{fgetc} для побайтового чтения файла. Программа \texttt{xxd} для просмотра байт файла.
\end{enumerate}





\iffalse
\newpage
\section*{Модуль 2}
\item  \textbf{Вычислительная сложность, $O(n)$ нотация}\\
Что такое $O(n)$, $\Omega(n)$ и $\Theta(n)$ нотации, математическое определение и смысл. Машина Тьюринга (детерминистическая и недетерминистическая). Классы сложности задач: $P$, $NP$, $PSPACE$, $EXPTIME$ и $EXPSPACE$.
Знать(или уметь выводить) сложности всех пройденных алгоритмов: алгоритм бинарного поиска в отсортированном массиве, алгоритмы сортировки (пузырьком, вставками, выбором, быстрая, сортировка слиянием, подсчётом, цифровая). Знать или уметь выводить сложности операций с пройденными структурами данных: поиск элемента по индексу в массиве и списке, вставка в массив(статический и динамический) и список; удаление из массива и списка; поиск по массиву и списку.

\item \textbf{Сортировка}\\
Парадигма разделяй и властвуй. Как возникает логарифмическая сложность в задачах, решаемых с помощью метода разделяй и властвуй. Алгоритм бинарного поиска в отсортированном массиве.
Сортировки пузырьком, вставками, выбором, быстрая, слиянием, подсчётом, цифровая и $Bogosort$. Вычислительные сложности всех этих алгоритмов. Уметь писать сортировку выбором, быструю сортировку и сортировку подсчётом. Cтандартная функция \texttt{qsort}. Функция компаратор \texttt{cmp}. Сортировка с помощью бинарного дерева поиска и с помощью бинарной кучи.


\item  \textbf{Абстрактные типы данных. Стек и очередь}\\
Структуры данных и абстрактный типы данных. Абстрактный тип данных Стек. Операции push и pop. Реализация стека на основе динамического массива. Динамическое выделение памяти для стека. Стратегии перевыделения памяти: аддитивная и мультипликативная. Абстрактный тип данных Очередь. Реализация очереди на основе динамического массива. Реализация стека и очереди на основе связного списка. Алгоритмические сложности операций со стеком.

\item \textbf{Связный список}\\
Связный список. Узел связного списка. Реализация связного списка на языке C. Функции нахождения длины списка, вставки элемента в начало/конец, удаления элемента из начала/конца, поиска в списке, обращения списка. Алгоритмические сложности операций со списком. Двусвязный список.


\item \textbf{Деревья}\\
Определение графа. Определение дерева. Бинарное дерево. Бинарное дерево поиска(bst). Высота дерева. Представление бинарного дерева в языке C. Операции поиска, добавления и удаления элемента в бинарном дереве поиска. Вычислительные сложности этих операций. Сбалансированное дерево. Два распространённых приёма для балансировки бинарных деревьев поиска (AVL-деревья и красно-чёрные деревья). Определение AVL-дерева. Операции вращения. Операции поиска, добавления и удаления элемента в AVL-дерево. Вычислительные сложности этих операций. Абстрактные типы данных множество (set) и словарь (dictionary).


\item \textbf{Хеш-таблица}\\
Что такое хеш-функция? Свойства хорошей хеш-функции. Что такое хеш-таблица? Добавление/удаление элемента в хеш-таблицу. Поиск элемента в хеш-таблице. Вычислительная сложность операций с хеш-таблицей. Абстрактные типы данных множество и словарь на основе хеш-таблицы. Чем различие между реализацие множества и словаря на основе сбалансированного дереве и на основе хеш-таблицы.



\item \textbf{Этапы компиляции}\\
Что такое файл исходного кода и исполняемый файл. Этап компиляции: препроцессинг, компиляция и линковка. Директивы препроцессора \texttt{\#include}, \texttt{\#define}, \texttt{\#ifdef}, \texttt{\#else} и \texttt{\#endif} и оператор \texttt{defined}. Компиляция программы с помощью \texttt{gcc}. Опции \texttt{gcc: -E, -c, -S}.


\item \textbf{* Очередь с приоритетом. Двоичная куча}\\
Хранение бинарных деревьев в массиве. Структура данных - двоичная куча. Операции добавления элемента в кучу. Операция удаления максимального элемента из кучи. Вычислительные сложности этих операций. Абстрактный тип данных - очередь с приоритетом. Реализация очереди с приоритетом с помощью двоичной кучи. Пирамидальная сортировка.

\fi
\end{enumerate}



\end{document}