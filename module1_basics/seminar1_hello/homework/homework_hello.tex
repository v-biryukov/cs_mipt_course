\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{empheq}


\makeatletter
\def\@bignumber#1#2{%
  \ifx#2\end
    #1\let\next\@gobble
  \else
    #1\hspace{0pt plus 1pt}\let\next\@bignumber
  \fi
  \next#2}
\newcommand{\bignumber}[1]{\@bignumber#1\end}
\makeatother

\usepackage{listings}
%\setlength{\columnsep}{1.5cm}
%\setlength{\columnseprule}{0.2pt}

\usepackage[absolute]{textpos}

\begin{document}
\pagenumbering{gobble}

\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}

\renewcommand{\thesubsection}{\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\@ifundefined{#1@cntformat}%
   {\csname the#1\endcsname\quad}
   {\csname #1@cntformat\endcsname}}
\newcommand\section@cntformat{}     
\newcommand\subsection@cntformat{Задача \thesubsection.\space} 
\newcommand\subsubsection@cntformat{\thesubsubsection.\space}
\makeatother


\title{Семинар \#1: Основы. Домашнее задание.\vspace{-5ex}}\date{}\maketitle


\subsection{Условие:} 
Напишите программу, которая будет считывать число и проверять, является ли число чётным и принадлежащим следующему множеству 
$[0, 20] \cup (100, 200)$ и печатать \texttt{Yes} или \texttt{No}. Используйте один оператор \texttt{if}.

\begin{center}
\begin{tabular}{ l l | l l }
 вход & выход & вход & выход \\ \hline
 \texttt{4} & \texttt{Yes} & \texttt{22} & \texttt{No}   \\ 
 \texttt{5} & \texttt{No} &\texttt{100} & \texttt{No}  \\ 
 \texttt{20} & \texttt{Yes} & \texttt{102} & \texttt{Yes} \\ 
\end{tabular}
\end{center}


\subsection{Число, квадрат и куб:} 
Напишите программу, которая будет печатать само число, его квадрат и его куб от \texttt{1} до \texttt{n}, разделённые стрелочкой.
Число \texttt{n} считывается с помощью \texttt{scanf}. 
Например, при \texttt{n = 5}, программа должна напечатать следующее:
\begin{verbatim}
1 ->  1 ->   1
2 ->  4 ->   8
3 ->  9 ->  27
4 -> 16 ->  64
5 -> 25 -> 125
\end{verbatim}
Для того чтобы все числа печатались выровнено, можно использовать спецификатор \texttt{\%3i} за место \texttt{\%i} в \texttt{printf}. В этом случае, если число имеет в записи меньше 3-х цифр, то \texttt{printf} напечатает необходимое число пробелов перед числом.



\subsection{Последовательность:} 
Пример программы, которая считывает число \texttt{n}. Затем считывает \texttt{n} чисел и находит среди них максимум. 

\begin{lstlisting}
#include <stdio.h>
#include <limits.h>
int main() 
{
    int n;
    scanf("%i", &n);
    int max = INT_MIN;
    for (int i = 0; i < n; ++i) 
    {
        int a;
        scanf("%i", &a);
        if (a > max)
            max = a;
    }
    printf("Max = %i\n", max);
}
\end{lstlisting}
В этой программе используется константа \texttt{INT\_MIN} из библиотеки \texttt{limits.h}. Эта константа равна минимальному возможному значению чисел типа \texttt{int}, то есть \texttt{INT\_MIN = -2147483648}. В этой задаче нельзя использовать массивы.
Измените программу выше так чтобы программа находила максимум и количество элементов, равных этому максимуму.
\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{3 1 2 3} & \texttt{3 1}  \\ 
 \texttt{3 7 7 7} & \texttt{7 3}  \\
 \texttt{10 1 8 2 4 8 8 1 5 2 8} & \texttt{8 4}
\end{tabular}
\end{center}

\newpage
\subsection{Числа-градины:}
Пусть нам на вход поступает число \texttt{n}. Мы преобразуем это число следующим образом $n = f(n)$, где
\begin{equation*}
f(n) = 
\left\{
\begin{alignedat}{2}
 &3 n + 1, &\quad \textup{если } n - \textup{нечётное}\\
 &n / 2,   & \textup{если } n - \textup{чётное}
\end{alignedat}
\right.
\end{equation*}
Затем повторяем этот алгоритм до тех пор пока число не достигнет единицы. Получится некоторая последовательность. Например, если изначально 
\texttt{n = 7}, то последовательность будет выглядеть следующим образом:
\begin{verbatim}
7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
\end{verbatim}
Ваша задача заключается в том, чтобы напечатать эту последовательность, её длину и максимальный элемент этой последовательность по изначальному числу \texttt{n}.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} & \texttt{3 10 5 16 8 4 2 1}  \\ 
   & \texttt{Length = 8, Max = 16}  \\ \hline
\texttt{256} & \texttt{256 128 64 32 16 8 4 2 1}  \\ 
   & \texttt{Length = 9, Max = 256}  \\ \hline
 \texttt{7} & \texttt{7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1}  \\ 
   & \texttt{Length = 17, Max = 52}  \\
\end{tabular}
\end{center}



\subsection{Сумма:}
На вход программе подаются два целых числа \texttt{n} и \texttt{m}. Нужно посчитать следующую сумму:
\begin{align*}
  S_{n,m} &= \sum_{i=1}^{n} \sum_{j=1}^{m} (-1)^{i + j} i \cdot j \\
\end{align*}
Например, если \texttt{n = 3}, а \texttt{m = 4}, то сумма будет равна:
\begin{align*}
  S_{3,4} &= 1 - 2 + 3 - 4 - 2 + 4 - 6 + 8 + 3 - 6 + 9 - 12 = -4\\
\end{align*}

\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{1 1}  & \texttt{1}  \\ 
 \texttt{2 2} & \texttt{1}  \\ 
 \texttt{3 3} & \texttt{4}  \\ 
 \texttt{3 4} & \texttt{-4}  \\  
 \texttt{5 7} & \texttt{12}  \\  
 \texttt{10 10} & \texttt{25}  \\  
 \texttt{77 107} & \texttt{2106}  \\ 
\end{tabular}
\end{center}


\subsection{Печать всех делимых:}
На вход программе подаются числа \texttt{a}, \texttt{b}, \texttt{c}. Программа должна напечатать все числа, делящиеся на \texttt{c} на отрезке \texttt{[a, b]} через пробел. Решите эту задачу как можно более эффективно.

\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{1 20 4}  & \texttt{4 8 12 16 20}  \\ 
 \texttt{1 20 7} &  \texttt{7 14}  \\ 
 \texttt{1 10000 9500} & \texttt{9500}  \\ 
 \texttt{1 1000000000 500000000} & \texttt{500000000 1000000000} \\
 \texttt{1 1000000000 123456789} & \texttt{123456789 246913578 370370367 493827156}  \\ 
                                 & \texttt{617283945 740740734 864197523 987654312}  \\   
\end{tabular}
\end{center}


\subsection{Повтор массива}
На вход программе приходит количество элементов некоторой последовательности, а затем сама последовательность. Вам нужно напечатать эту последовательность 2 раза.

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{4} & \texttt{10 20 30 40 10 20 30 40}  \\  
 \texttt{10 20 30 40} &  \\ \hline
 \texttt{1} & \texttt{123 123}  \\  
 \texttt{123} &  \\ 
\end{tabular}
\end{center}

\subsection{Операция над массивом}
Ниже приведён пример программы, которая считывает массив, затем удаляет первый элемент в этом массиве и печатает массив на экран:
\begin{lstlisting}
#include <stdio.h>
int main() 
{
    int a[1000];
    int n;
    scanf("%i", &n);
    for (int i = 0; i < n; ++i)
        scanf("%i", &a[i]);
 
    for (int i = 0; i < n - 1; ++i)
        a[i] = a[i + 1];
    n--;    
    
    for (int i = 0; i < n; ++i)
        printf("%i ", a[i]);

    printf("\n");
}
\end{lstlisting}
Напишите программу, которая будет считывать массив и удалять все отрицательные элементы из массива, а затем печатать этот массив на экран. Постарайтесь написать как можно более эффективный код. Например, каждый элемент нужно переместить максимум 1 раз. Вам нужно изменить сам массив, а не просто напечатать отдельные его элементы.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 2 5}  \\  
 \texttt{0 -1 2 -3 -4 5} &  \\ \hline
 \texttt{2} & \texttt{9}  \\  
 \texttt{9 -5} &  \\ 
\end{tabular}
\end{center}



\subsection{Сумма столбцов}
На вход поступают размеры матрицы \texttt{n} и \texttt{m} и элементы матрицы. Нужно найти сумму элементов в каждом столбце. Для этой задачи не нужно использовать двумерный массив, достаточно будет одномерного.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3 4} &    \texttt{14 15 16 12}  \\ 
 \texttt{1 2 3 6} &  \\
 \texttt{6 5 4 2} &  \\ 
 \texttt{7 8 9 4} &  \\ 
\end{tabular}
\end{center}


\subsection{Сортировка по сумме цифр}
На вход подаётся последовательность чисел. Отсортируйте эти числа по возрастанию суммы цифр.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{401 15 516 932 96 673}  \\  
 \texttt{673 96 15 401 932 516} &  \\
\end{tabular}
\end{center}
В файле \texttt{numbers.txt} хранится 10000 чисел. Используйте перенаправление потока, чтобы отсортировать эти числа по сумме цифр. Сохраните результат в файле \texttt{sorted.txt}. Нужно написать в терминал следующее:

\begin{verbatim}
a.exe < numbers.txt > sorted.txt
\end{verbatim}





\subsection{Умножение матриц}
На вход поступает число \texttt{n} и две квадратных матрицы размера \texttt{nxn}. Нужно перемножить эти матрицы и напечатать результат. Формула перемножения матриц:
$$
C_{ij} = \sum\limits_{k=0}^{n-1} A_{ik} \cdot B_{kj}
$$.
\begin{multicols}{2}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} &     \texttt{21 30 130}  \\ 
 \texttt{7 7 2} & \texttt{-6 21 82}  \\
 \texttt{1 8 3} & \texttt{48 12 -1}  \\ 
 \texttt{2 1 6} &  \\ 
 \texttt{} &  \\
 \texttt{5 2 9} &  \\
 \texttt{-4 2 11} &  \\ 
 \texttt{7 1 -5} &  \\ 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} &     \texttt{55 60 70}  \\ 
 \texttt{5 2 9} & \texttt{-4 -1 64}  \\
 \texttt{-4 2 11} & \texttt{40 52 -13}  \\ 
 \texttt{7 1 -5} &  \\ 
 \texttt{} &  \\
 \texttt{7 7 2} &  \\
 \texttt{1 8 3} &  \\ 
 \texttt{2 1 6} &  \\ 
\end{tabular}
\end{center}
\end{multicols}

В файле \texttt{matAB.txt} сохранены две матрицы \texttt{10x10}. Используйте перенаправление потока, чтобы считать эти матрицы из файла \texttt{matAB.txt}, перемножьте их и сохраните в новый файл \texttt{matC.txt}. Нужно написать в терминал следующее:
\begin{verbatim}
a.exe < matAB.txt > matC.txt
\end{verbatim}

В результате должна получиться такая матрица:
\begin{center}
$
\begin{pmatrix}
259 & -15 & 237 & 257 &  231 &  67  & 237  & -64  & 152  & 363 \\
555 & 233 & 539 & 188 &  356 &  325 &  423 &  -47 &  123 &  387 \\
497 & 512 & 572 & 95  & 619  & 155  & 414  & 207  & 203  & 217 \\
455 & 280 & 675 & 354 &  664 &  346 &  483 &  177 &  168 &  404 \\
264 & 182 & 272 & 290 &  474 &  -33 &  234 &  99  & 379  & 156 \\
272 & 180 & 469 & 286 &  326 &  282 &  325 &  215 &  195 &  231 \\
421 & 363 & 475 & 506 &  359 &  481 &  468 &  101 &  325 &  328 \\
384 & 218 & 567 & 395 &  475 &  488 &  361 &  168 &  291 &  298 \\
387 & 297 & 480 & 170 &  318 &  423 &  483 &  10  & -17  & 406 \\
193 & 241 & 486 & 38  & 403  & 146  & 286  & 326  & 212  & 172 \\
\end{pmatrix}
$
\end{center}










\newpage
\section*{Необязательные задачи (не входят в ДЗ, никак не учитываются)}
\setcounter{subsection}{0}

\subsection{Три числа:}
На вход программе подаются три числа: \texttt{a}, \texttt{b} и \texttt{c}. Нужно проверить следующие условия:
\begin{enumerate}
\item Если числа \texttt{a}, \texttt{b} и \texttt{c} являются последовательными, то нужно напечатать \texttt{Consecutive}.
\item Если последовательность \texttt{a}, \texttt{b}, \texttt{c} является возрастающей, то нужно напечатать \texttt{Increasing}.
\item Если последовательность \texttt{a}, \texttt{b}, \texttt{c} является убывающей, то нужно напечатать \texttt{Decreasing}.
\item Если все три числа равны, то нужно напечатать \texttt{Equal}.
\item В ином случае нужно напечатать \texttt{None}.
\end{enumerate}

\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{1 2 3} & \texttt{Consecutive Increasing}  \\ 
 \texttt{1 2 4} & \texttt{Increasing}  \\
 \texttt{1 1 2} & \texttt{None} \\ 
 \texttt{1 2 1} & \texttt{None} \\ 
 \texttt{1 5 9} & \texttt{Increasing}  \\ 
 \texttt{1 0 -1} & \texttt{Consecutive Decreasing}  \\ 
 \texttt{1 5 4} & \texttt{None} \\ 
 \texttt{7 7 7} & \texttt{Equal} \\  
 \texttt{20 15 5} & \texttt{Decreasing} \\
\end{tabular}
\end{center}


\subsection{Последовательность++:} 
Пример программы, которая считывает число \texttt{n}. Затем считывает \texttt{n} чисел и находит среди них максимум. 

\begin{lstlisting}
#include <stdio.h>
#include <limits.h>
int main() 
{
    int n;
    scanf("%i", &n);
    int max = INT_MIN;
    for (int i = 0; i < n; ++i) 
    {
        int a;
        scanf("%i", &a);
        if (a > max)
            max = a;
    }
    printf("Max = %i\n", max);
}
\end{lstlisting}
В этой программе используется константа \texttt{INT\_MIN} из библиотеки \texttt{limits.h}. Эта константа равна минимальному возможному значению чисел типа \texttt{int}, то есть \texttt{INT\_MIN = -2147483648}. В этой задаче нельзя использовать массивы.
\subsubsection*{Подзадачи:}
Измените программу выше так чтобы:
\begin{enumerate}
\item Программа находила минимум, а не максимум. Может понадобиться константа \texttt{INT\_MAX = 2147483647}.
\item Программа находила минимальное чётное число и максимальное нечётное. Если чётных или нечётных чисел нет, то программа должна печатать \texttt{None} за место числа.
\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{3 4 5 6} & \texttt{4 5}  \\ 
 \texttt{3 7 7 7} & \texttt{None 7}  \\
 \texttt{10 1 8 2 4 8 8 1 5 2 8} & \texttt{2 5} \\
 \texttt{4 10 8 6 8} & \texttt{6 None}
\end{tabular}
\end{center}

\item Программа печатала \texttt{Increasing} если последовательность чисел строго возрастает, \texttt{Decreasing}, если последовательность чисел строго убывает и \texttt{Equal}, если все члены последовательности равны. В любом ином случае программа должна печатать \texttt{None}.
\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{3 1 2 3} & \texttt{Increasing}  \\ 
 \texttt{3 7 7 7} & \texttt{Equal}  \\
 \texttt{5 20 15 10 7 5} & \texttt{Decreasing}  \\ 
 \texttt{4 1 1 4 5} & \texttt{None}
\end{tabular}
\end{center}
\end{enumerate}


\subsection{Числа-градины II:}
На вход поступает 2 числа \texttt{a} и \texttt{b}. Нужно найти такое число \texttt{n} ($a \le n \le b$), для которого последовательность чисел-градин будет самой длинной. Нужно напечатать число \texttt{n}, а также длину последовательности, которая начинается с \texttt{n}.
\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{1 5}  & \texttt{3 8}  \\ 
 \texttt{1 8} & \texttt{7 17}  \\ 
 \texttt{1 10} & \texttt{9 20}  \\ 
 \texttt{10 15} & \texttt{14 18}  \\ 
 \texttt{1 100} & \texttt{97 119}  \\ 
 \texttt{1 500} & \texttt{327 144}  \\ 
 \texttt{400 500} & \texttt{487 142}  \\ 
 \texttt{1 1000} & \texttt{871 179}  \\ 
 \texttt{1 10000} & \texttt{6171 261}  \\ 
 \texttt{1 100000} & \texttt{77031 351}  \\ 
\end{tabular}
\end{center}



\subsection{Пифагоровы тройки:}
На вход приходит целое число \texttt{n}. Нужно напечатать все возможные пифагоровы тройки $a$, $b$ и $c$, такие что $a \le n$, $b \le n$ и $c \le n$. Пифагорова тройка -- это тройка натуральных чисел, для которых верно:
$$
a^2 + b^2 = c^2
$$

Пифагоровы тройки, получаемые из некоторой пифагоровой тройки путём обмена местами чисел $a$ и $b$ считаются дублирующими. Пифагоровы тройки, получаемые из некоторой пифагоровой тройки путём умножения всех чисел на некоторое натуральное число, также считаются дублирующими. Печатать дублирующие тройки не нужно.

\textit{Подсказка:} Просто переберите все возможные значения $a$, $b$ и $c$.

\begin{center}
\begin{tabular}{ l l }
 вход & выход \\ \hline
 \texttt{15}  & \texttt{3 4 5}  \\ 
              & \texttt{5 12 13}  \\ 
 \texttt{50}  & \texttt{3 4 5}  \\
              & \texttt{5 12 13}  \\ 
              & \texttt{8 15 17}  \\ 
              & \texttt{7 24 25}  \\ 
              & \texttt{20 21 29}  \\ 
              & \texttt{12 35 37}  \\ 
              & \texttt{9 40 41} 
\end{tabular}
\end{center}

\subsection{Операции над массивом++}
Во всех подзадачах этой задачи вам нужно изменить массив \texttt{a} и, возможно, размер \texttt{n} между считыванием массива и его печатью. Каждая программа должна иметь такой вид:
\begin{lstlisting}
#include <stdio.h>
int main() 
{
    int a[1000];
    int n;
    scanf("%i", &n);
    for (int i = 0; i < n; ++i)
        scanf("%i", &a[i]);

    // ||||| Ваш код между считыванием и печатью массива  |||||
    
    
    // ||||||||||||||||||||||||||||||||||||||||||||||||||||||||
    for (int i = 0; i < n; ++i)
        printf("%i ", a[i]);

    printf("\n");
}
\end{lstlisting}
Внутри вашего кода нужно считать дополнительные данные и изменить массив и переменную \texttt{n}.

\begin{enumerate}
\item \textbf{Удвоение массива:} Нужно увеличить массив \texttt{a} в 2 раза, заполнив новую часть копией массива \texttt{a}. Предполагается, что количество места в массиве (\texttt{1000}) больше чем \texttt{2n}, то есть места хватит. Не забудьте изменить переменную \texttt{n}.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{4} & \texttt{0 1 2 3 0 1 2 3}  \\  
 \texttt{0 1 2 3} &  \\ \hline
 \texttt{3} & \texttt{6 4 3 6 4 3}  \\
 \texttt{6 4 3} &  \\  
\end{tabular}
\end{center}

\item \textbf{Вставка:} На вход подаётся массив, новый элемент массива и индекс -- положение в массиве, после которого нужно вставить элемент. Чтобы освободить место в массиве нужно передвинуть часть элементов вправо. Предполагается, что количество места в массиве (\texttt{1000}) больше чем \texttt{n}, то есть места на 1 элемент хватит. Будьте осторожны, не перепишите элементы массива при их перемещении. Не забудьте изменить переменную \texttt{n}.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 1 2 9 3 4 5}  \\  
 \texttt{0 1 2 3 4 5} &  \\ 
 \texttt{9 2} &   \\ \hline
 \texttt{2} & \texttt{1 5 4}  \\  
 \texttt{1 5} &  \\ 
 \texttt{4 1} &   \\
\end{tabular}
\end{center}

\item \textbf{Удаление:} На вход подаётся массив и индекс элемента, который нужно удалить. При этом понадобится передвинуть часть элементов влево.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 1 2 4 5}  \\  
 \texttt{0 1 2 3 4 5} &  \\ 
 \texttt{3} &   \\ \hline
 \texttt{2} & \texttt{5}  \\  
 \texttt{1 5} &  \\ 
 \texttt{0} &   \\
\end{tabular}
\end{center}

\item \textbf{Удаление подмассива:} На вход подаётся массив и подмассив(2 индекса). Нужно удалить этот подмассив из массива. Постарайтесь написать как можно более эффективный код. Например, каждый элемент нужно переместить только 1 раз.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 4 5}  \\  
 \texttt{0 1 2 3 4 5} &  \\ 
 \texttt{1 4} &   \\ \hline
 \texttt{9} & \texttt{2 1}  \\  
 \texttt{9 8 7 6 5 4 3 2 1} &  \\ 
 \texttt{0 7} &   \\
\end{tabular}
\end{center}
\item \textbf{Разделение на чётные/нечётные:} Переставьте элементы массива \texttt{a} так, чтобы сначала в нём шли нечётные элементы, а потом чётные. Причём порядок следования внутри чётной или нечётной части не важен. Эту задачу можно решить с использованием дополнительных массивов, а можно и без них.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{7} & \texttt{1 3 5 0 4 2 6}  \\  
 \texttt{0 1 2 3 4 5 6} & \\ \hline
 \texttt{9} & \texttt{9 7 5 3 1 8 2 4 6}  \\  
 \texttt{9 8 7 6 5 4 3 2 1} &  \\ \hline
 \texttt{2} & \texttt{1 2}  \\  
 \texttt{2 1} &  \\
\end{tabular}
\end{center}

\item \textbf{Раздвоение:} Увеличьте массив в 2 раза, раздвоив каждый элемент. Постарайтесь написать более оптимальный код без использования дополнительного массива.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{0 0 1 1 2 2 3 3 4 4 5 5}  \\  
 \texttt{0 1 2 3 4 5} & \\ \hline
 \texttt{1} & \texttt{1 1}  \\  
 \texttt{1} &  \\
\end{tabular}
\end{center}
\item \textbf{Циклический сдвиг:} На вход подаётся массив и целое положительное число \texttt{k} нужно циклически сдвинуть массив на \texttt{k} элементов вправо.
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{6} & \texttt{4 5 0 1 2 3}  \\  
 \texttt{0 1 2 3 4 5} & \\
 \texttt{2} & \\ \hline
 \texttt{6} & \texttt{1 2 3 4 5 0}  \\  
 \texttt{0 1 2 3 4 5} & \\
 \texttt{5} & \\ 
\end{tabular}
\end{center}
\textit{Подсказка:} Новое положение \texttt{i}-го элемента в массиве будет задаваться формулой \texttt{(i + k) \% n}. Эту задачу проще всего решить с использованием дополнительного массива, но можно и без него.
\end{enumerate}


\subsection{Сортировка столбцов}
На вход поступают размеры матрица \texttt{n} и \texttt{m} и элементы матрицы. Нужно отсортировать элементы в каждом столбце.
\begin{multicols}{2}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{5 3} &    \texttt{1 1 1} \\ 
 \texttt{8 1 9} &  \texttt{2 2 3}\\
 \texttt{2 5 1} &  \texttt{4 2 7}\\ 
 \texttt{7 5 7} &  \texttt{7 5 7}\\ 
 \texttt{4 2 3} &  \texttt{8 5 9}\\ 
 \texttt{1 2 7} &  \\ 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{2 6} &          \texttt{5 2 1 3 1 2} \\ 
 \texttt{6 2 8 3 2 4} &  \texttt{6 4 8 5 2 4}\\
 \texttt{5 4 1 5 1 2} & \\ 
\end{tabular}
\end{center}
\end{multicols}



\subsection{Нижняя граница}
Пусть дан массив и некоторое число \texttt{x}. Нижняя граница -- это индекс первого элемент, который больше или равен \texttt{x}. Напишите эффективную программу, которая ищет нижнюю границу на отсортированном массиве. Если такого элемента нет, то нужно вернуть \texttt{n}.

\begin{multicols}{3}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{7} & \texttt{3}  \\  
 \texttt{1 1 1 2 2 5 6} & \\
 \texttt{2} & \\ \hline
 \texttt{7} & \texttt{4}  \\  
 \texttt{0 1 1 2 6 6 9} & \\
 \texttt{3} & \\ 
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{5} & \texttt{4}  \\  
 \texttt{1 2 3 4 5} & \\
 \texttt{5} & \\ \hline
 \texttt{5} & \texttt{0}  \\  
 \texttt{1 1 1 1 1} & \\
 \texttt{1} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} & \texttt{0}  \\  
 \texttt{2 2 6} & \\
 \texttt{1} & \\ \hline
 \texttt{3} & \texttt{3}  \\  
 \texttt{2 2 6} & \\
 \texttt{9} & \\
\end{tabular}
\end{center}
\end{multicols}



\subsection{Поиск пика}
Пусть дан массив. Известно, что у этого массива и первые \texttt{k >= 0} элементов строго возрастают, а остальные -- строго убывают. Напишите эффективную программу, которая будет искать индекс пика (максимального элемента) в этом массиве. Используйте
бинарный поиск, чтобы сделать алгоритм поиска пика более эффективным.

\begin{multicols}{3}
\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{7} & \texttt{3}  \\  
 \texttt{1 2 3 4 3 2 1} & \\\hline
 \texttt{7} & \texttt{1}  \\  
 \texttt{1 9 8 6 4 3 1} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{5} & \texttt{4}  \\  
 \texttt{1 2 3 4 5} & \\ \hline
 \texttt{5} & \texttt{3}  \\  
 \texttt{1 2 3 9 1} & \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ l | l }
 вход & выход \\ \hline
 \texttt{3} & \texttt{1}  \\  
 \texttt{1 2 1} & \\ \hline
 \texttt{1} & \texttt{0}  \\  
 \texttt{5} & \\
\end{tabular}
\end{center}
\end{multicols}

\end{document}