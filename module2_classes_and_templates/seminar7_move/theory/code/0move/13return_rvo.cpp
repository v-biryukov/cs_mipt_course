/*
    Перемещение используется и при возврате из функции.
    Но при этом самостоятельно писать std::move в этом случае не нужно. 
    Дело в том, что при возврате из функции компилятор может сделать RVO оптимизацию.
    И, несмотря на то, что перемещение часто намного быстрее, чем полное копирование,
    всё же перемещение медленне, чем RVO, так как при RVO объект сразу создаётся в вызывающей функции.


    Рассмотрим данный пример. В функции getNumbers1 вектор возвращается обычным образом.
    Но при этом никакого копирования при возврате из функции не происходит, так как срабатывает RVO оптимизация.
    В этом можно убедиться, если сравнить адреса &v и &v[0] внутри функции и те же адреса у вектора v функции main.

    Если же мы добавим при возвращении std::move, то для возврата объект будет использоваться перемещение.
    То есть функция будет работать медленней.
*/

#include <vector>
#include <iostream>
#include <utility>
using std::cout, std::endl;


std::vector<int> getNumbers1()
{
    std::vector<int> v {10, 20, 30, 40, 50};
    cout << "Address of v: " << &v << ", address of v[0] " << &v[0] << endl;
    return v;
}


std::vector<int> getNumbers2()
{
    std::vector<int> v {10, 20, 30, 40, 50};
    cout << "Address of v: " << &v << ", address of v[0] " << &v[0] << endl;
    return std::move(v);
}


int main()
{
    auto a = getNumbers1();
    cout << "Address of a: " << &a << ", address of a[0] " << &a[0] << endl;
}