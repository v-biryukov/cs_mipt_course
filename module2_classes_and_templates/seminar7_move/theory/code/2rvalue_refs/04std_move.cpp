/*
    Стандартная функция std::move

    Иногда нам хочется передать lvalue выражение в функцию, которая принимает rvalue-ссылку.
    Для этого можно использовать функцию std::move.

    На самом деле, функция std::move ничего не перемещает, как может показаться из названия.
    Всё что делает функция std::move - это просто конвертирует категорию выражения к rvalue.

    Можно убедиться что и в этом случае никакого перемещения объекта a не происходит.
    Рассмотрим подробно, что происходит в этой строке:

        func(std::move(a));

    В этой строке происходит следующее:

        1)  lvalue-выражение  a  передаётся в функцию std::move и конвертируется к rvalue.

        2)  Так как std::move(a) - это rvalue, то выбирается перегрузка   void func(std::string&& s)

        3)  В эту функцию передаются ссылка на a.
            Обратите внимание, что ссылка передаётся уже не на временный объект, а на объект a.
            При этом никакого копирование или перемещения объекта a не происходит.
*/

#include <iostream>
#include <string>
#include <utility>
using std::cout, std::endl;


void func(std::string& s)
{
    cout << "Pass by lvalue reference" << endl;
}

void func(std::string&& s)
{
    cout << "Pass by rvalue reference" << endl;
}

int main()
{
    std::string a {"Cat"};

    func(a);
    cout << a << endl;

    func(std::move(a));
    cout << a << endl;
}


/*
    Задача:

        Если мы передадим объект в функцию, принимающую rvalue-ссылку, с помощью std::move,
        а затем изменим этот объект в этой функции с помощью rvalue-ссылки, то изменится ли этот
        объект вне функции?
*/