/*
    Перегрузка по lvalue-ссылкам и rvalue-ссылкам

    Как было сказано раньше, функции можно перегружать по категории передаваемого выражения.
    В этом примере есть две перегрузки функции func.
    Одна перегрузка принимает lvalue-ссылку, а вторая принимает rvalue-ссылку.
    Таким образом, разные функции будут вызываться при передаче в функцию выражений разных категорий.

    
    Ещё раз напомним, что при передаче rvalue-выражения в функцию принимающую объект по rvalue-ссылке
    никакого перемещения не происходит, а в функцию просто передаётся ссылка на временный объект.
    Почти также как и при передаче по обычной ссылке, но только ссылка будет на временный объект.

    Рассмотри подробно, что будет происходить при следующем вызове:

        func(a + b);

    В этом случае произойдёт следующее:

        1)  Для вычисления суммы строк вызовется перегруженный оператор+ класса std::string.
            Этот метод вернёт временный объект - строку являющуюся результатом конкатенации строк a и b.


        2)  Так как выражение a + b это rvalue, то на этапе компиляции была выбрана перегрузка   
            void func(std::string&& s)


        3)  В эту функцию передастся ссылка на временный объект.
            При этом сам временный объект не будет копироваться или перемещаться.
            Время жизни временного объекта будет продлено до завершения функции.
*/

#include <iostream>
#include <string>
using std::cout, std::endl;


void func(std::string& s)
{
    cout << "Pass by lvalue reference" << endl;
}

void func(std::string&& s)
{
    cout << "Pass by rvalue reference" << endl;
}

int main()
{
    std::string a = "Cat";
    std::string b = "Dog";

    func(a);
    func(a + b);
    func(a.substr(0, 2));
}