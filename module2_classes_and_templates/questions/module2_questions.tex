\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}
\lstset{
  language=C,                % choose the language of the code
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,                   % where to put the line-numbers
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,                   % the step between two line-numbers.        
  numbersep=10pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showstringspaces=false,         % underline spaces within strings
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=true,         % sets if automatic breaks should only happen at whitespace
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}
\lstset{literate=%
   *{0}{{{\color{red!20!violet}0}}}1
    {1}{{{\color{red!20!violet}1}}}1
    {2}{{{\color{red!20!violet}2}}}1
    {3}{{{\color{red!20!violet}3}}}1
    {4}{{{\color{red!20!violet}4}}}1
    {5}{{{\color{red!20!violet}5}}}1
    {6}{{{\color{red!20!violet}6}}}1
    {7}{{{\color{red!20!violet}7}}}1
    {8}{{{\color{red!20!violet}8}}}1
    {9}{{{\color{red!20!violet}9}}}1
}


\begin{document}
\pagenumbering{gobble}

\section*{C++. Модуль 1. Вопросы.}


\begin{enumerate}
\item \textbf{Ссылки, вектор и строка}

\begin{enumerate}[a.]
\item \textbf{Пространства имён}\\
Пространство имён: что такое и зачем нужно. Директива \texttt{using namespace}. \texttt{using}-объявление.
Пространство имён \texttt{std}.

\item \textbf{Ссылки}\\
Что такое ссылки? Различие ссылок и указателей. Константные ссылки. Три типа передачи аргументов в функцию: передача по значению, передача по ссылке и передача по константной ссылке. Преимущества/недостатки каждого метода. Возврат ссылки из функции. Висячие ссылки.

\item  \textbf{Перегрузка функций}\\
Сигнатуры функций. Перегрузка функций. Выбор функции при перегрузке.


\item \textbf{Класс \texttt{std::string}}\\
Стандартная строка \texttt{std::string}. Преимущества строки \texttt{std::string} по сравнению со строкой в стиле \texttt{C}. Конструкторы класса \texttt{std::string}. Работа с отдельными символами в строке. Библиотека \texttt{cctype}. Строение объектов класса \texttt{std::string}, его размер.  Методы класса строки: \texttt{push\_back}, \texttt{pop\_back}, \texttt{insert}, \texttt{clear}, \texttt{erase}, \texttt{substr}, \texttt{find}, \texttt{starts\_with},  \texttt{c\_str}, \texttt{size}, \texttt{capacity}, \texttt{reserve}, \texttt{resize} и \texttt{shrink\_to\_fit}. Передача строк в функции. Конвертация чисел в строки и наоборот. Чтение в строку. Функция \texttt{std::getline}. Литералы типа \texttt{std::string} из пространства имён \texttt{std::string\_literals}. Оптимизация малой строки (SSO).


\item \textbf{Класс \texttt{std::vector}}\\
Контейнер \texttt{std::vector}. Внутренее устройство вектора. Конструкторы вектора. Доступ к отдельным элементам в векторе. Методы вектора: \texttt{push\_back}, \texttt{pop\_back}, \texttt{begin}, \texttt{end}, \texttt{front}, \texttt{back}, \texttt{clear}, \texttt{empty}, \texttt{data}, \texttt{size}, \texttt{capacity}, \texttt{reserve}, \texttt{resize}, \texttt{shrink\_to\_fit}. Передача вектора в функции.


\item \textbf{Приведение типов в C++}\\
Опасность приведения в стиле C. 
Оператор приведения \texttt{static\_cast}. Отличие приведения типов с помощью оператора \texttt{static\_cast} от приведения типов в стиле C. То есть чем
\begin{lstlisting}
static_cast<type>(a)
\end{lstlisting}
отличается от:
\begin{lstlisting}
(type)(a)
\end{lstlisting}
Оператор приведения \texttt{reinterpret\_cast}. 
Оператор приведения \texttt{const\_cast}.
\end{enumerate}



\item \textbf{Классы}

\begin{enumerate}[a.]

\item \textbf{Классы}\\
Объектно-ориентированное программирование. Класс. Поля и методы класса. Члены класса.
Инкапсуляция. Константные методы класса. Указатель \texttt{this}. Сокрытие данных. Модификаторы доступа \texttt{private} и \texttt{public}. Различие ключевых слов \texttt{struct} и \texttt{class} при объявлении классов.
Геттеры и сеттеры. Друзья классов. Вложенные классы. Использование \texttt{typedef} внутри класса.

\item \textbf{Конструкторы и деструкторы}\\
Когда вызываются конструкторы, а когда деструкторы? Можно ли перегружать конструкторы и деструкторы? Различные синтаксисы вызова конструктора (с использованием знака \texttt{=}, с использованием круглых скобок и с использованием фигурных скобок). Конструкторы и передача в функции/возврат из функций. Делегирующий конструктор. Идиома RAII. 


\item \textbf{Перегрузка операторов}\\
Перегрузка операторов в языке C++. Перегрузка арифметических операторов. Перегрузка унарных операторов. Перегрузка операторов как свободных функций и как методов класса. Перегрузка оператора присваивания. Перегрузка оператора присваивания сложения.  Перегрузка оператора индексирования (квадратные скобки). Перегрузка операторов инкремента и декремента. Перегрузка оператора стрелочка (\texttt{->}). Перегрузка оператора вызова функции (круглые скобки). Перегрузка операторов \verb|<<| и \verb|>>| с объектами типа \texttt{std::ostream} и \texttt{std::istream}. 


\item \textbf{Реализация своего класса строки}\\
Уметь писать свой простейший класс строки.
Методы такой строки:
\begin{itemize}
\item Конструктор по умолчанию
\item Конструктор, принимающий строку в стиле C (\texttt{const char*})
\item Конструктор копирования
\item Деструктор
\item Оператор присваивания
\item Оператор присваивания сложения(\texttt{+=}). 
\item Оператор сложения. Реализация оператора сложения с помощью оператора присваивания сложения (\texttt{+=}).
\item Операторы сравнения.
\item Оператор индексирования.
\end{itemize}

\item \textbf{Раздельная компиляция}\\
Вынос определений функций из класса. Forward declaration. Вынос определений функций в другие \texttt{.cpp} файлы.


\end{enumerate}





\item \textbf{Инициализация}

\begin{enumerate}[a.]
\item \textbf{Виды инициализации}\\
Что такое инициализация? Классификация типов на скалярные типы, агрегатные типы и нормальные классы.
Виды инициализации: \textit{default initialization}, \textit{value initialization}, \textit{direct initialization}, \textit{copy initialization}. \texttt{explicit}-конструкторы.


\item \textbf{Инициализация полей класса}\\
Когда инициализируются поля класса? Инициализация полей класса по умолчанию.
Список инициализации полей класса. 

\item \textbf{Особые методы класса}\\
Конструктор по умолчанию. Конструктор копирования. Оператор присваивания копирования. Деструктор. Конструктор перемещения. Оператор присваивания перемещения. При каких условиях компилятор автоматически создаёт эти методы.
Что делают особые методы, автоматически созданные компилятором? Правило пяти. Удалённые функции и методы, ключевое слово \texttt{delete}. Ключевое слово \texttt{default} для особых методов класса.

\item \textbf{Динамическое создание объектов в куче}\\
Создание/удаление объектов в куче с помощью операторов \texttt{new} и \texttt{delete}. Создание/удаление массива объектов в куче с помощью операторов \texttt{new[]} и \texttt{delete[]}. Основные отличия \texttt{new} и \texttt{delete} от \texttt{malloc} и \texttt{free}. Оператор \texttt{placement new}. Как оператор \texttt{new} возвращает ошибку при нехватки памяти?

\item \textbf{Статические поля и методы}\\
Статическое поле. Инициализация статического поля. Статические методы.


\item \textbf{Основы работы с исключениями}\\
Зачем нужны исключения, в чём их преимущество перед другими методами обработки ошибок? Оператор \texttt{throw}. Что происходит после достижения программой оператора \texttt{throw}. Раскручивание стека. Блок \texttt{try}-\texttt{catch}. Что произойдёт, если выброшенное исключение не будет поймано? Стандартные классы исключений: \texttt{std::exception}, \texttt{std::runtime\_error}, \texttt{std::bad\_alloc}, \texttt{std::bad\_cast}, \texttt{std::logic\_error}.


\end{enumerate}





\item \textbf{Шаблоны}

\begin{enumerate}[a.]
\item \textbf{Шаблоны функций}\\
Шаблоны функций. Автоматический вывод типа для шаблона функции. Ограничения, накладываемые на тип шаблона функции. Шаблоны функций и перегрузка. Шаблоны с нетиповыми параметрами. Два этапа компиляции шаблона. Инстанцирование шаблона. Зависимые имена в шаблонах.

\item \textbf{Шаблоны классов}\\
Шаблоны классов. Вывод шаблонных аргументов классов. 

\item \textbf{Стандартные шаблонные классы}\\
Класс вектора \texttt{std::vector<T>}. Класс массива \texttt{std::array<T, Size>}. Чем \texttt{std::array} отличается от \texttt{std::vector}? Чем \texttt{std::array} отличается от массива языка C? Класс пары \texttt{std::pair} и как его применять. Поля \texttt{first} и \texttt{second}.
Класс \texttt{std::optional<T>}. Методы класса \texttt{std::optional}: \texttt{value},  \texttt{has\_value} \texttt{value\_or}. Объект \texttt{std::nullopt}. Конструкторы класса \texttt{optional}: конструктор по умолчанию, конструктор от объекта типа \texttt{T}, конструктор от другого \texttt{std::optional}.


\item \textbf{\texttt{auto}}\\
Ключевое слово \texttt{auto}. Range-based циклы. Structured bindings.
Использование \texttt{auto} для типа возвращаемого значения функции. Использование \texttt{auto} для параметров функций.


\item \textbf{Вариативные шаблоны}\\
Использование вариативных шаблонов.
\end{enumerate}




\item \textbf{Контейнеры}
\begin{enumerate}[a.]

\item \textbf{Итераторы}\\
Идея итераторов. В чём преимущество итераторов по сравнению с обычным обходом структур данных? Операции, которые можно производить с итератором вектора. Обход стандартных контейнеров с помощью итераторов. Передача итераторов в функции. Константные и обратные итераторы. Методы \texttt{begin}, \texttt{end}, \texttt{cbegin}, \texttt{cend}, \texttt{rbegin} и \texttt{rend}.

\item \textbf{Класс списка \texttt{std::list}}\\
С помощью какой структуры данных реализован список \texttt{std::list}? Как устроен список, где и как хранятся данные в списке? Итератор списка \texttt{std::list<T>::iterator}. Операции, которые можно производить с итератором списка. Методы списка: \texttt{insert}, \texttt{erase}, \texttt{push\_back}, \texttt{push\_front}, \texttt{pop\_back}, \texttt{pop\_front}. Вычислительная сложность этих операций.  Как удалить элементы списка во время прохода по нему? 
Контейнер \texttt{std::forward\_list}.

\item \textbf{Класс двухсторонней очереди \texttt{std::deque}}\\
Как устроена двухсторонняя очередь, где и как хранятся данные в ней? Операций, которые можно с ней провести и их вычислительная сложность.

\item \textbf{Контейнеры-множества}\\
Контейнер \texttt{std::set} -- множество. Его основные свойства. С помощью какой структуры данных он реализован? Методы \texttt{insert}, \texttt{erase}, \texttt{find}, \texttt{count}, \texttt{lower\_bound}, \texttt{upper\_bound} и их вычислительная сложность. Как изменить элемент множества? Контейнер \texttt{std::unordered\_set} -- неупорядоченное множество. Его основные свойства. С помощью какой структуры данных он реализован? Основные методы этого контейнера и их вычислительная сложность. Контейнеры \texttt{multuset} и \texttt{unordered\_multuset}.

\item \textbf{Контейнеры-словари}\\
Контейнер \texttt{std::map} -- словарь. Его основные свойства. Методы \texttt{insert}, \texttt{operator[]}, \texttt{erase}, \texttt{find}, \texttt{count}, \texttt{lower\_bound}, \texttt{upper\_bound} и их вычислительная сложность. Контейнер \texttt{std::unordered\_map}. С помощью какой структуры данных этот контейнер реализован? Его основные свойства и методы и их вычислительная сложность. Как изменить ключ элемента словаря?  Контейнеры \texttt{multumap} и \texttt{unordered\_multumap}. Как удалить из \texttt{multimap} все элементы с данным ключом? Как удалить из \texttt{multimap} только один элемент с данным ключом? 

\item \textbf{* Настройка множеств и словарей}\\
Пользовательский компаратор для упорядоченных ассоциативных контейнеров.
Пользовательский компаратор и пользовательская хеш-функция для неупорядоченнных ассоциативных контейнеров.

\item \textbf{* Инвалидация итераторов}\\
Инвалидация итераторов вектора. Инвалидация итераторов списка. Инвалидация итераторов множества и словаря.

\end{enumerate}




\item \textbf{Алгоритмы}
\begin{enumerate}[a.]

\item \textbf{Основные алгоритмы}\\
Библиотека \texttt{algorithm}. Стандартные шаблонные функции из этой библиотеки: \texttt{max\_element}, \texttt{sort}, \texttt{reverse}, \texttt{count}, \texttt{find}, \texttt{all\_of}, \texttt{any\_of}, \texttt{none\_of}, \texttt{fill}, \texttt{unique}, \texttt{remove}. Библиотека \texttt{numeric}. Стандартные функции из этой библиотеки: \texttt{iota} и \texttt{accumulate}. Как написать подобные алгоритмы самостоятельно?


\item \textbf{Output и Input итераторы}\\
Output итераторы. Итератор \texttt{std::back\_insert\_iterator}. Как перегружены операторы для этого итератора? Использование функции \texttt{std::copy} и этого итератора для вставки элементов в контейнер. Итератор \texttt{std::ostream\_iterator}, как перегружены операторы для этого итератора.
Input итераторы. Итератор \texttt{std::istream\_iterator}, как перегружены операторы для этого итератора.


\item \textbf{Категории итераторов}\\
Различие между итератором вектора и итератором списка. Какие операции можно применять к итератору вектора, но нельзя применять к итератору списка? Категории итераторов (Input, Output, Forward, Bidirectional, Random access). Допустимые операции для каждой категории итераторов. Привести пример итератора из каждой категории. Почему нельзя сортировать контейнер типа \texttt{std::list} с помощью стандартной функции \texttt{std::sort}? Функции \texttt{std::advance}, \texttt{std::next} и \texttt{std::distance}.


\item \textbf{Функциональные объекты}\\
Тип функция. Тип указатель на функцию. Функтор. Различие между функцией и функтором. Стандартные функторы: \texttt{std::less}, \texttt{std::greater}, \texttt{std::equal\_to}, \texttt{std::plus}, \texttt{std::minus}, \texttt{std::multiplies}. Лямбда-функции. Передача функциональных объектов в функции.

\item \textbf{Алгоритмы, принимающие функциональные объекты}\\
Стандартные функции, принимающие функциональные объекты: \texttt{for\_each}, \texttt{sort}, \texttt{stable\_sort}, \texttt{find\_if}, \texttt{count\_if}, \texttt{all\_of}, \texttt{generate}, \texttt{copy\_if}, \texttt{transform}, \texttt{partition}, \texttt{stable\_partition}. Как написать подобные алгоритмы самостоятельно?

\item \textbf{Лямбда-захват}\\
Захват локальных переменных по ссылке и по значению. Опасность захвата по ссылке.

\end{enumerate}



\item \textbf{Move семантика}
\begin{enumerate}[a.]

\item \textbf{Перемещение}\\
Операция копирования. Что происходит при копировании (разберите случаи копирования скаляра, агрегата и нормального класса)? Операция перемешения. Что происходит при перемещении (разбирите случаи перемещения скаляра, агрегата и нормального класса)? Стандартная функция \texttt{std::move}. Что происходит при перемещении объектов классов \texttt{std::string} и \texttt{std::vector}? В чём преимущества перемещения над копированием? Когда происходит перемещение? Перемещение объекта в функцию, если функция принимает объект по значению.

\item \textbf{lvalue-выражения и rvalue-выражения}\\
Что такое выражение? Тип выражения и категория выражения. Что такое lvalue-выражение? Что такое rvalue-выражение? Приведите примеры lvalue и rvalue выражений. Зачем нужно разделение выражений на lvalue и rvalue? Передача lvalue и rvalue выражений в функции, принимающие по значению.

\item \textbf{lvalue-ссылки и rvalue-ссылки}\\
Что такое lvalue-ссылки, а что такое rvalue-ссылки, в чём разница?  Перегрузка по категории выражения. Уметь написать функцию, которая печатает категорию переданого ей выражения. Какую категорию имеет выражение, состоящее только из одного идентификатора -- rvalue-ссылки? Что на самом деле делает функция \texttt{std::move}?

\item \textbf{Особые методы, связанные с перемещением}\\
Конструктор перемещения и оператор присваивания перемещения. Создание класса, с пользовательским конструктором перемещения и пользовательским оператором перемещения. Правило пяти.

\end{enumerate}




\item \textbf{Умные указатели}
\begin{enumerate}[a.]

\item \textbf{Ошибки при работе с динамической памятью}\\
Утечки памяти. Утечки памяти при бросании исключений. Двойное удаление.

\item \textbf{Умный указатель \texttt{std::unique\_ptr}}\\
Применение класса \texttt{std::unique\_ptr} Основные свойства \texttt{std::unique\_ptr}. 
Методы \texttt{operator*}, \texttt{operator->}, \texttt{get}, \texttt{release}.
Ошибочное использование \texttt{std::unique\_ptr} при его инициализации с помощью обычного указателя. Шаблонная функция \texttt{std::make\_unique}. Перемещение объектов типа \texttt{unique\_ptr}. Передача таких указателей в функции.


\item \textbf{* Реализация класса \texttt{std::unique\_ptr}}\\
Нужно уметь писать класс, аналогичный классу \texttt{std::unique\_ptr}. Циклические ссылки и \texttt{std::unique\_ptr}.

\item \textbf{* Умный указатель \texttt{std::shared\_ptr}}\\
Зачем нужен умный указатель \texttt{std::shared\_ptr}? В чём его преемущество по сравнению с обычными указателями и с \texttt{std::unique\_ptr}? Шаблонная функция \texttt{std::make\_shared}. Как схематически устроен указатель типа \texttt{std::shared\_ptr}. Циклические ссылки и \texttt{std::shared\_ptr}. Умный указатель \texttt{std::weak\_ptr}.


\end{enumerate}

\end{enumerate}

\end{document}