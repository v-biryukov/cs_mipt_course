\documentclass{article}
\usepackage[utf8x]{inputenc}
\usepackage{ucs}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{upgreek}
\usepackage[english,russian]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{textcomp}
\usepackage{hyperref}
\usepackage{multicol}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{ccaption}
\usepackage{mathrsfs}
\usepackage[shortlabels]{enumitem}
\usepackage{listings}
\lstset{
  language=C,
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,
  numbersep=10pt,
  backgroundcolor=\color{white},
  showstringspaces=false,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=true,
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
}


\begin{document}
\pagenumbering{gobble}

\section*{C++. Модуль 1. Вопросы.}


\begin{enumerate}
\item \textbf{Пространства имён, ссылки, перегрузка функций, строка и вектор}

\begin{enumerate}[a.]
\item \textbf{Пространства имён}\\
Зачем нужны пространства имён? Оператор разрешения области видимости. Директива \texttt{using namespace}. \texttt{using}-объявление. Пространства имён и заголовочные файлы. Псевдонимы пространств имён. 
Пространство имён \texttt{std}.

\item \textbf{Ссылки}\\
Отличие ссылок от указателей. Инициализация ссылок. Константные ссылки. Продление времени жизни временных объектов. Три типа передачи аргументов в функцию: передача по значению, передача по ссылке и передача по константной ссылке. Преимущества/недостатки каждого метода. Возврат ссылки из функции. Висячие ссылки.

\item  \textbf{Перегрузка функций}\\
Сигнатура функции. По каким составляющим можно перегружать функцию, а по каким нельзя? Перегрузка при неявных преобразованиях. Выбор функции при перегрузке. 

\item  \textbf{Манглирование имён}\\
Исполняемые и объектные файлы. Символы. Утилиты \texttt{nm}, \texttt{strings} и \texttt{c++filt}. \texttt{extern "C"}.


\item \textbf{Класс \texttt{std::string}}\\
Стандартная строка \texttt{std::string}. Преимущества строки \texttt{std::string} по сравнению с C-строкой. Конструкторы класса \texttt{std::string}. Работа с отдельными символами в строке. Библиотека \texttt{cctype}. Методы класса строки:
\vspace{-2mm}
\begin{multicols}{2}
\begin{itemize}
\item \texttt{begin}, \texttt{end}, \texttt{rbegin}, \texttt{rend} и т. д.
\item \texttt{operator[]}, \texttt{at}, \texttt{front} и \texttt{back}
\item \texttt{clear} и \texttt{empty}
\item \texttt{push\_back} и \texttt{pop\_back}
\item \texttt{insert} и \texttt{erase}
\item \texttt{substr}
\item \texttt{find}
\item \texttt{starts\_with} и \texttt{ends\_with}
\item \texttt{swap}
\item \texttt{c\_str}, \texttt{size} и \texttt{capacity}
\item \texttt{reserve} и \texttt{resize}
\item \texttt{shrink\_to\_fit}
\end{itemize}
\end{multicols}
\vspace{-2mm}
Статическая константа \texttt{std::string::npos}. Перегруженные операторы \texttt{std::string}. Вычислительная сложность всех методов. Передача строк в функции. Конвертация чисел в строки и наоборот. Чтение в строку. Функция \texttt{std::getline}. Литералы типа \texttt{std::string} из пространства имён \texttt{std::string\_literals}. Строение объектов класса \texttt{std::string} и их размер. Оптимизация малой строки (SSO).


\item \textbf{Класс \texttt{std::vector}}\\
Контейнер \texttt{std::vector}. Конструкторы вектора. Доступ к отдельным элементам в векторе. Присваивание векторов. Методы вектора:
\vspace{-2mm}
\begin{multicols}{2}
\begin{itemize}
\item \texttt{begin}, \texttt{end}, \texttt{rbegin}, \texttt{rend} и т. д.
\item \texttt{front} и \texttt{back}
\item \texttt{operator[]} и \texttt{at}
\item \texttt{clear} и \texttt{empty}
\item \texttt{push\_back} и \texttt{pop\_back}
\item \texttt{insert} и \texttt{erase}
\item \texttt{swap}
\item \texttt{data}, \texttt{size} и \texttt{capacity}
\item \texttt{reserve} и \texttt{resize}
\item \texttt{shrink\_to\_fit}
\end{itemize}
\end{multicols}
\vspace{-2mm}
Вычислительная сложность всех методов. Передача вектора в функции. Внутренее устройство вектора. Стратегия роста.


\item \textbf{Приведение типов в C++}\\
Опасность приведения в стиле C. 
Оператор приведения \texttt{static\_cast}. Отличие приведения типов с помощью оператора \texttt{static\_cast} от приведения типов в стиле C. То есть чем
\begin{lstlisting}
static_cast<type>(a)
\end{lstlisting}
отличается от:
\begin{lstlisting}
(type)(a)
\end{lstlisting}
Оператор приведения \texttt{reinterpret\_cast}. 
Оператор приведения \texttt{const\_cast}.
\end{enumerate}



\newpage
\item \textbf{Классы}

\begin{enumerate}[a.]

\item \textbf{Классы}\\
Объектно-ориентированное программирование. Класс. Члены класса. Поля и методы класса.  Инкапсуляция. Константные методы класса. Указатель \texttt{this}. Сокрытие данных. Модификаторы доступа \texttt{private} и \texttt{public}. Различие ключевых слов \texttt{struct} и \texttt{class} при объявлении классов. Геттеры и сеттеры. Друзья классов. Вложенные классы. Псевдонимы типа внутри класса. Использование \texttt{typedef} и \texttt{using} для создания псевдонимов типов внутри класса.

\item \textbf{Конструкторы и деструкторы}\\
Когда вызываются конструкторы, а когда деструкторы? Можно ли перегружать конструкторы и деструкторы? Различные синтаксисы вызова конструктора: с использованием знака \texttt{=}, с использованием круглых скобок и с использованием фигурных скобок. Конструкторы и передача в функции/возврат из функций. Использование конструктора для явного и неявного приведения типов. Делегирующий конструктор. Идиома RAII. 


\item \textbf{Перегрузка операторов}\\
Перегрузка операторов как свободных функций и как методов класса. Какие операторы можно перегружать, а какие нельзя? Перегрузка оператора присваивания. Перегрузка операторов инкремента и декремента. Перегрузка оператора стрелочка (\texttt{->}). Перегрузка операторов приведения и ключевое слово \texttt{explicit}. Перегрузка операторов \texttt{new} и \texttt{delete}. Перегрузка операторов \verb|<<| и \verb|>>| с объектами типа \texttt{std::ostream} и \texttt{std::istream}. 


\item \textbf{Реализация своего класса строки}\\
Уметь писать свой простейший класс строки.
Методы такой строки:
\begin{itemize}
\item Конструктор по умолчанию
\item Конструктор, принимающий строку в стиле C (\texttt{const char*})
\item Конструктор копирования
\item Деструктор
\item Оператор присваивания
\item Оператор присваивания сложения(\texttt{+=}). 
\item Оператор сложения. Его реализация с помощью операторов \texttt{=} и \texttt{+=}.
\item Операторы сравнения.
\item Оператор индексирования.
\end{itemize}

\item \textbf{Раздельная компиляция}\\
Вынос определений функций из класса. Forward declaration. Вынос определений функций в другие \texttt{.cpp} файлы.


\end{enumerate}





\item \textbf{Инициализация}

\begin{enumerate}[a.]
\item \textbf{Виды инициализации}\\
Что такое инициализация? Классификация типов на скалярные типы, агрегатные типы и нормальные классы.
Виды инициализации: \textit{default initialization}, \textit{value initialization}, \textit{direct initialization}, \textit{copy initialization}. \texttt{explicit}-конструкторы.


\item \textbf{Инициализация полей класса}\\
Когда инициализируются поля класса? Инициализация полей класса по умолчанию. Список инициализации полей класса. Порядок инициализации полей класса. Инициализация константных полей и полей-ссылок.

\item \textbf{Особые методы класса}
\begin{itemize}
\item Конструктор по умолчанию
\item Деструктор
\item Конструктор копирования
\item Оператор присваивания копирования
\item Конструктор перемещения
\item Оператор присваивания перемещения
\end{itemize}
При каких условиях компилятор автоматически создаёт эти методы? Что делают особые методы, автоматически созданные компилятором? Правило пяти. Удалённые функции и методы, ключевое слово \texttt{delete}. Ключевое слово \texttt{default} для особых методов класса.

\item \textbf{Избегание копирования}\\
Оптимизация Copy Elision и когда она происходит?

\item \textbf{Динамическое создание объектов в куче}\\
Создание/удаление объектов в куче с помощью операторов \texttt{new} и \texttt{delete}. Создание/удаление массива объектов в куче с помощью операторов \texttt{new[]} и \texttt{delete[]}. Основные отличия \texttt{new} и \texttt{delete} от \texttt{malloc} и \texttt{free}. Оператор \texttt{placement new}. Как оператор \texttt{new} возвращает ошибку при нехватки памяти?

\item \textbf{Статические поля и методы}\\
Статическое поле. Инициализация статического поля. Инициализация \texttt{const static} полей. Статические методы.


\item \textbf{Обработка ошибок}\\
Классификация ошибок. Ошибки времени компиляции, ошибки линковки, ошибки времени выполнения, логические ошибки. Внутренние и внешние ошибки. Обработка ошибок с помощью макроса \texttt{assert}. Обработка ошибок с использованием глобальной переменной \texttt{errno}. Обработка ошибок c помощью кодов возврата. В чём недостатки кодов возврата? Использование класса \texttt{std::optional} для кодов возврата. Обработка ошибок с использованием исключений.

\item \textbf{Основы работы с исключениями}\\
Преимущества и недостатки исключений перед другими методами обработки ошибок. Оператор \texttt{throw}. Какие типы объектов можно "бросать"? Что происходит после достижения программой оператора \texttt{throw}? Раскручивание стека. Блок \texttt{try}-\texttt{catch}. Перехват по типу. Что произойдёт, если выброшенное исключение не будет поймано? \texttt{catch (...)}. Повторное выбрасывание исключения. Исключения в деструкторах. Стандартные классы исключений: \texttt{std::exception}, \texttt{std::runtime\_error}, \texttt{std::logic\_error}. Метод \texttt{what}. Конструкции языка, которые бросают исключения. \texttt{std::bad\_alloc}. Функции стандартной библиотеки, которые бросают исключения.


\end{enumerate}





\item \textbf{Шаблоны}

\begin{enumerate}[a.]
\item \textbf{Шаблоны функций}\\
Шаблоны функций. Инстанцирование шаблона. Автоматический вывод типа для шаблона функции. Ограничения, накладываемые на тип шаблона функции. Шаблонные аргументы по умолчанию. Шаблоны функций и перегрузка.  Шаблоны с нетиповыми параметрами. Два этапа компиляции шаблона. Правила вывода типа шаблонной функции.


\item \textbf{\texttt{auto} и вывод типа}\\
Ключевое слово \texttt{auto}. Вывод типа при использовании \texttt{auto}. Различие этого вывода от вывода типа шаблонной функции (\texttt{std::initializer\_list}). \texttt{auto} и возвращаемые значения. Trailing return type. Использование \texttt{auto} для параметров функций. Range-based цикл \texttt{for}. Структурное связывание. \texttt{decltype}.

\item \textbf{Шаблоны классов}\\
Шаблоны классов. Вывод шаблонных аргументов классов (CTAD).
Зависимые имена в шаблонах. Использование ключевых слов \texttt{typename} и \texttt{template} для правильной интерпретации зависимых имён. Специализация шаблонов. Полная специализация. Частичная специализация. \texttt{std::vector<bool>}.

\item \textbf{Стандартные шаблонные классы}
\begin{enumerate}
\item Класс вектора \texttt{std::vector<T>}.
\item Класс массива \texttt{std::array<T, Size>}. Чем \texttt{std::array} отличается от \texttt{std::vector}? Чем \texttt{std::array} отличается от массива языка C?
\item Класс пары \texttt{std::pair}. Поля \texttt{first} и \texttt{second}. Создание пары. Сравнение пар.
\item Класс \texttt{std::optional<T>}. Конструкторы класса \texttt{optional}. Методы класса \texttt{std::optional}:
\vspace{-2mm}
\begin{multicols}{2}
\begin{itemize}
\item \texttt{operator*}
\item \texttt{value}
\item \texttt{has\_value}
\item \texttt{operator bool()}
\item \texttt{reset}
\item \texttt{value\_or}
\end{itemize}
\end{multicols}
\vspace{-2mm}
Объект \texttt{std::nullopt}.
\end{enumerate}


\item \textbf{Вариативные шаблоны}\\
Пак типов. Пак параметров. Распаковка пака типов и пака параметров. Оператор \texttt{sizeof...}. Рекурсивная обработка пакета. Fold expressions. Использование оператора запятая в fold expressions.
\end{enumerate}




\newpage
\item \textbf{Контейнеры}
\begin{enumerate}[a.]

\item \textbf{Итераторы}\\
Идея итераторов. В чём преимущество итераторов по сравнению с обычным обходом структур данных? Операции, которые можно производить с итератором вектора. Обход стандартных контейнеров с помощью итераторов. Передача итераторов в функции. Константные и обратные итераторы. Методы \texttt{begin}, \texttt{end}, \texttt{cbegin}, \texttt{cend}, \texttt{rbegin} и \texttt{rend}.

\item \textbf{Класс списка \texttt{std::list}}\\
С помощью какой структуры данных реализован список \texttt{std::list}? Как устроен список, где и как хранятся данные в списке?  Методы списка: \texttt{insert}, \texttt{erase}, \texttt{push\_back}, \texttt{push\_front}, \texttt{pop\_back}, \texttt{pop\_front}. Вычислительная сложность всех методов. Итератор списка \texttt{std::list<T>::iterator}. Операции, которые можно производить с итератором списка. Сортировка списка. Как удалить элементы списка во время прохода по нему?  Контейнер \texttt{std::forward\_list}.

\item \textbf{Класс двухсторонней очереди \texttt{std::deque}}\\
Как устроена двухсторонняя очередь, где и как хранятся данные в ней? Операций, которые можно с ней провести и их вычислительная сложность.

\item \textbf{Контейнеры-множества}\\
Контейнер \texttt{std::set} -- множество. Его основные свойства. С помощью какой структуры данных он реализован? Методы \texttt{insert}, \texttt{erase}, \texttt{find}, \texttt{count}, \texttt{lower\_bound}, \texttt{upper\_bound} и их вычислительная сложность. Как изменить элемент множества? Контейнер \texttt{std::unordered\_set} -- неупорядоченное множество. Его основные свойства. С помощью какой структуры данных он реализован? Основные методы этого контейнера и их вычислительная сложность. Контейнеры \texttt{multuset} и \texttt{unordered\_multuset}.

\item \textbf{Контейнеры-словари}\\
Контейнер \texttt{std::map} -- словарь. Его основные свойства. С помощью какой структуры данных он реализован? Методы \texttt{insert}, \texttt{operator[]}, \texttt{erase}, \texttt{find}, \texttt{count}, \texttt{lower\_bound}, \texttt{upper\_bound} и их вычислительная сложность. Контейнер \texttt{std::unordered\_map}. С помощью какой структуры данных реализован? Его основные свойства и методы и их вычислительная сложность. Как изменить ключ элемента словаря?  Контейнеры \texttt{multumap} и \texttt{unordered\_multumap}. Как удалить из \texttt{multimap} все элементы с данным ключом? Как удалить из \texttt{multimap} только один элемент с данным ключом? 

\item \textbf{Инвалидация итераторов}\\
Инвалидация итераторов вектора. Инвалидация итераторов списка. Инвалидация итераторов множества и словаря.

\item \textbf{Контейнерные адаптеры}\\
Шаблонный параметр шаблона. Контейнерный адаптер \texttt{std::stack} и его методы \texttt{push}, \texttt{pop} и \texttt{top}. Почему метод \texttt{pop} не возвращает элемент? Контейнерный адаптер \texttt{std::queue} и его методы \texttt{push}, \texttt{pop}, \texttt{front} и \texttt{back}. Контейнерный адаптер \texttt{std::priority\_queue} и его методы \texttt{push}, \texttt{pop} и \texttt{top}. Задание базового контейнера для адаптера.

\item \textbf{Настройка множеств и словарей}\\
Пользовательский компаратор для упорядоченных ассоциативных контейнеров.
Пользовательский компаратор и пользовательская хеш-функция для неупорядоченнных ассоциативных контейнеров.

\end{enumerate}




\item \textbf{Алгоритмы}
\begin{enumerate}[a.]

\item \textbf{Основные алгоритмы}\\
Библиотека \texttt{algorithm}. Стандартные шаблонные функции из этой библиотеки: \texttt{max\_element}, \texttt{sort}, \texttt{reverse}, \texttt{copy}, \texttt{count}, \texttt{find}, \texttt{all\_of}, \texttt{any\_of}, \texttt{none\_of}, \texttt{fill}, \texttt{unique}, \texttt{remove}. Библиотека \texttt{numeric}. Стандартные функции из этой библиотеки: \texttt{iota} и \texttt{accumulate}. Как написать подобные алгоритмы самостоятельно?


\item \textbf{Output и Input итераторы}\\
Output итераторы. Итератор \texttt{std::back\_insert\_iterator}. Как перегружены операторы для этого итератора? Использование функции \texttt{std::copy} и этого итератора для вставки элементов в контейнер. Итератор \texttt{std::ostream\_iterator}, как перегружены операторы для этого итератора?
Input итераторы. Итератор \texttt{std::istream\_iterator}, как перегружены операторы для этого итератора?


\item \textbf{Категории итераторов}\\
Различие между итератором вектора и итератором списка. Какие операции можно применять к итератору вектора, но нельзя применять к итератору списка? Категории итераторов: Input, Output, Forward, Bidirectional, Random access. Допустимые операции для каждой категории итераторов. Привести пример итератора из каждой категории. Почему нельзя сортировать контейнер типа \texttt{std::list} с помощью стандартной функции \texttt{std::sort}? Функции \texttt{std::advance}, \texttt{std::next} и \texttt{std::distance}.


\item \textbf{Функциональные объекты}\\
Тип функция. Тип указатель на функцию. Функтор. Различие между функцией и функтором. Стандартные функторы: \texttt{std::less}, \texttt{std::greater}, \texttt{std::equal\_to}, \texttt{std::plus} и другие. Лямбда-функции. Передача функциональных объектов в функции.

\item \textbf{Указатели на поля и методы}\\
Тип указателя на поле. Тип указателя на метод. Операторы \texttt{.*} и \texttt{->*}. Конвертация указателя на метод к функциональному объекту. Функция \texttt{std::mem\_fn}.

\item \textbf{Алгоритмы, принимающие функциональные объекты}\\
Стандартные функции, принимающие функциональные объекты: \texttt{for\_each}, \texttt{sort}, \texttt{stable\_sort}, \texttt{find\_if}, \texttt{count\_if}, \texttt{all\_of}, \texttt{generate}, \texttt{copy\_if}, \texttt{transform}, \texttt{partition}, \texttt{stable\_partition}. Как написать подобные алгоритмы самостоятельно?

\item \textbf{Лямбда-функции}\\
Простые лямбда-функции без захвата. Лямбда функции как функторы. Создание переменной лямбда-функции. Захват локальных переменных. Захват по ссылке и по значению. Опасность захвата по ссылке. Возвращаемый тип лямбда-функции. Захват \texttt{this} и \texttt{*this}. Создание и инициализация полей лямбда функции. Захват переменных с перемещением. Модификатор \texttt{mutable}.

\item \textbf{Класс \texttt{std::function}}\\
Хранение функциональных объектов в объекте класса \texttt{std::function}. Современный аналог -- класс \texttt{std::copyable\_function}.
\end{enumerate}



\item \textbf{Move семантика}
\begin{enumerate}[a.]

\item \textbf{Перемещение}\\
Операция копирования. Что происходит при копировании (разберите случаи копирования скаляра, агрегата и нормального класса)? Операция перемешения. Операция перемещающего присваивания. Что происходит при перемещении (разбирите случаи перемещения скаляра, агрегата и нормального класса)? Стандартная функция \texttt{std::move}. Что происходит при перемещении объектов типа \texttt{int}, \texttt{std::string}, \texttt{std::vector} и \texttt{std::array}? В чём преимущества перемещения над копированием? 

\item \textbf{lvalue-выражения и rvalue-выражения}\\
Что такое выражение? Тип выражения и категория выражения. Что такое lvalue-выражение? Что такое rvalue-выражение? Приведите примеры lvalue и rvalue выражений. Зачем нужно разделение выражений на lvalue и rvalue? Когда происходит перемещение? Передача lvalue и rvalue выражений в функции, принимающие по значению. Использование \texttt{std::move} при возврате из функции.

\item \textbf{lvalue-ссылки и rvalue-ссылки}\\
Разница между lvalue-ссылками и rvalue-ссылками. Инициализация ссылок. Возврат ссылок из функций. Приведение объектов к ссылкам. Перегрузка по категории выражения. Уметь написать функцию, которая печатает категорию переданого ей выражения. Какую категорию имеет выражение, состоящее только из одного идентификатора -- rvalue-ссылки? Что на самом деле делает функция \texttt{std::move}? Перегрузка по квалификаторам ссылок.

\item \textbf{Особые методы, связанные с перемещением}\\
Конструктор перемещения и оператор присваивания перемещения. Создание класса, с пользовательским конструктором перемещения и пользовательским оператором перемещения.

\end{enumerate}




\item \textbf{Умные указатели}
\begin{enumerate}[a.]

\item \textbf{Ошибки при работе с динамической памятью}\\
Утечки памяти. Утечки памяти при бросании исключений. Двойное удаление.

\item \textbf{Умный указатель \texttt{std::unique\_ptr}}\\
Применение класса \texttt{std::unique\_ptr}. Основные свойства \texttt{std::unique\_ptr}. 
Методы \texttt{operator*}, \texttt{operator->}, \texttt{operator bool()}, \texttt{get}, \texttt{release}, \texttt{swap}.Ошибочное использование \texttt{std::unique\_ptr} при его инициализации с помощью обычного указателя. Шаблонная функция \texttt{std::make\_unique}. Перемещение объектов типа \texttt{unique\_ptr}. Передача таких указателей в функции. Циклические ссылки.

\item \textbf{Умный указатель \texttt{std::shared\_ptr}}\\
Класс \texttt{std::shared\_ptr} и его отличие от \texttt{std::unique\_ptr}. Шаблонная функция \texttt{std::make\_shared}. Как схематически устроен указатель типа \texttt{std::shared\_ptr}? Циклические ссылки.

\end{enumerate}

\end{enumerate}

\end{document}