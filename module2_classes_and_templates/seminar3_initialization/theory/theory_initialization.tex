\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1.5cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{listings}
\usepackage{makecell}
\pagenumbering{gobble}

\lstdefinestyle{csMiptCppStyle}{
  language=C++,
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  texcl=true,
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,      
  numbersep=10pt,
  backgroundcolor=\color{white},
  showstringspaces=false,
  captionpos=b,
  breaklines=true
  breakatwhitespace=true,
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
  tabsize=4,
  upquote=true,
}
\lstdefinestyle{csMiptCppBorderStyle}{
  style=csMiptCppStyle,
  framexleftmargin=5mm, 
  frame=shadowbox, 
  rulesepcolor=\color{gray}
}

\lstset{style=csMiptCppStyle}
\lstset{literate={~}{{\raisebox{0.5ex}{\texttildelow}}}{1}}
\newcommand{\mytilde}{\raisebox{0.5ex}{\texttildelow}}


\begin{document}

\title{Семинар \#3: Инициализация.\vspace{-5ex}}\date{}\maketitle

\section*{Инициализация}

\textbf{Инициализация} -- это процесс присвоения начального значения переменной или объекту при их создании.

\subsection*{Инициализация в языке C}
Прежде чем углубляться в инициализацию в языке C++, давайте рассмотрим, как она реализована в языке C.
\begin{itemize}
\item По умолчанию объекты, созданные в сегментах стек и куча, не инициализируются. После создания объекта в них могут находиться произвольные значения:
\begin{lstlisting}
int a;      // a может иметь произвольное значение
int b[5];   // Элементы массива b могут иметь произвольные значения
Book c;     // Элементы структуры c могут иметь произвольные значения
\end{lstlisting}
\item Обычные переменные инициализируются с помощью знака равенства (\texttt{=}).
\begin{lstlisting}
int a = 10;
\end{lstlisting}
\item Массивы и структуры инициализируются с помощью знака равенства и фигурных скобок:
\begin{lstlisting}
int b[5] = {10, 20, 30, 40, 50};
Book c = {"Harry potter", 1000};
\end{lstlisting}
\item Инициализация происходит путём простого задания байтов объекта соответствующими значениями.
\end{itemize}

\subsection*{Инициализация в языке C++}
В C++ инициализация объектов усложняется из-за того, что в языке появляются классы, а объекты классов обычно инициализируются с вызовом конструктора. Для того чтобы разобраться как происходит инициализация объектов разных типов разделим типы C++ на следующие группы:
\begin{enumerate}
\item \textbf{Скалярные типы} -- это все числовые типы (как целочисленные, так и типы с плавающей точкой), булевый тип, указатели, а также перечисления.
\item \textbf{Агрегатные типы} -- к этой группе относятся:
\begin{itemize}
\item Массивы
\item Агрегатные классы. Это классы у которых нет ничего из перечисленного:
\begin{enumerate}
\item конструкторов (за исключением тех, что создаются автоматически)
\item приватных полей
\item виртуальных функций (виртуальных функций будут пройдены в курсе позже)
\end{enumerate}
\end{itemize}
\item \textbf{Нормальные классы} -- к этой группе относятся классы, которые не являются агрегатными.
\end{enumerate}
Такое разделение типов на группы позволяет лучше понять, что происходит при инициализации объектов, так как типы из разных групп инициализируются по-разному.

\begin{itemize}
\item Скаляры инициализируются посредством побайтового задания соответствующих значений.
\item Нормальные классы инициализируются посредством вызова соответствующего конструктора.
\item Агрегаты инициализируются поэлементно. Причём элементом объекта агрегатного типа может быть как скаляр, так и класс или другой агрегат. Для инициализации элементов агрегата применяются те же правила. То есть, если элемент агрегата является скаляром, то он инициализируются побайтово, если элемент агрегата является нормальным классом -- то через конструктор, а если элемент агрегата является другим агрегатом, то поэлементно.
\end{itemize}

\newpage
Можно выделить 4 разных вида инициализации: \textit{default-}, \textit{value-}, \textit{direct-} и \textit{copy-инициализация}. Разные виды инициализации различаются синтаксисом, который вызывает ту или иную инициализацию, а так же тем, что происходит во время этой инициализации. Инициализация может отличаться в зависимости от вида инициализации и инициализируемого типа. Можно составить следующую таблицу:\\

{\renewcommand{\arraystretch}{1.6}
\begin{tabular}{ m{1.9cm} | m{3.3cm}| m{3.5cm} | m{3.2cm}| m{3.2cm} } 
  \hline
   & Синтаксис & Скаляры & Агрегаты & Норм. Классы\\ 
  \hline
  \textit{Default initialization} & \makecell{\texttt{T x;}} & не инициализируются & \textit{Default initialization} для всех элементов & Конструктор по умолчанию \\ 
  
  \hline
   \textit{Value initialization} &\makecell{\texttt{T();}\\ \texttt{T x\{\};}} & инициализируются нулями & \textit{Value initialization} для всех элементов & Конструктор по умолчанию \\ 
  \hline
  
   \textit{Direct initialization} & \makecell{\texttt{T x(a);}\\ \texttt{T x\{a\};} \\ \texttt{T x(a, b, ...);}\\  \texttt{T x\{a, b, ...\};}}& инициализируются соответствующими значениями & \textit{Copy initialization} для всех элементов & Соответствующий конструктор \\ 
  \hline
  
    \textit{Copy initialization} & \makecell{\texttt{T x = a;} \\ \texttt{T x = \{a\};} \\ \texttt{T x = \{a, b, ...\};}\\ \texttt{func(a);}\\ \texttt{return a;}\\  \texttt{func(\{a, b, ...\});} \\ \texttt{return \{a, b, ...\};}}& инициализируются соответствующими значениями & \textit{Copy initialization} для всех элементов & Соответствующий не \texttt{explicit} конструктор \\ 
  \hline
\end{tabular}
}\\
\quad\\
Следует отметить, что эта таблица является неполной, существует ещё варианты синтаксиса когда вызывается та или иная инициализация. Но, тем не менее, эта таблица охватывает большинство случаев инициализации объектов в C++. Также, нужно отметить, что всё вышеперечисленное не относится к ссылкам. Ссылки инициализиуются по другим правилам, которые, правда, являются интуитивно понятными.

К сожалению, в некоторых случаях инициализация с использованием круглых скобок не будет работать, поскольку компилятор может испытывать трудности в различении между инициализацией и объявлением функции.


\subsection*{Примеры инициализации объектов в C++}
Примеры инициализации объекта скалярного типа \texttt{int}:
\begin{lstlisting}
int a;          // Default инициализация - a будет иметь произвольное значение
int b{};        // Value инициализация - b будет равно нулю
int c(10);      // Direct инициализация - c будет равно 10
int d{10};      // Direct инициализация - d будет равно 10
int e = 10;     // Copy инициализация - e будет равно 10
int f = int();  // int() - создаём временный объект типа int с помощью value инициализации,
                // затем инициализируем объект a, используя copy инициализацию 
                // f будет равен нулю
\end{lstlisting}
Примеры инициализации нормального класса \texttt{Cat}. Предположим, что у класса \texttt{Cat} есть конструктор по умолчанию и конструктор, принимающий один аргумент типа \texttt{int}.
\begin{lstlisting}
Cat a;          // Default инициализация - вызовется конструктор по умолчанию
Cat b{};        // Value инициализация - вызовется конструктор по умолчанию
Cat c(10);      // Direct инициализация - вызовется соответствующий конструктор
Cat d{10};      // Direct инициализация - вызовется соответствующий конструктор
Cat e = 10;     // Copy инициализация - вызовется соответствующий конструктор, но только если
                // этот конструктор НЕ является explicit. Если же соответствующий конструктор 
                // является explicit, то будет ошибка компиляции
\end{lstlisting}

\newpage


\subsection*{\texttt{explicit} конструкторы}
Любой конструктор можно пометить как \texttt{explicit} (\texttt{explicit} можно перевести как \textit{явный}). Такие конструкторы нельзя использовать для copy-инициализации. 
\begin{lstlisting}
#include <iostream>
#include <string>

struct Cat
{
	int x;
	explicit Cat(int x) 
	{
		std::cout << "Cat Constructor" << std::endl;
		this->x = x;
	}
};

void func(Cat c) {}

int main()
{
	Cat a(10);  // OK, explicit конструктор можно использовать для direct-инициализации
	Cat b = 10; // Ошибка, explicit конструктор нельзя использовать для copy-инициализации
	func(10);   // Ошибка, explicit конструктор нельзя использовать для copy-инициализации
}
\end{lstlisting}

\subsection*{Инициализация полей классов}
Объекты нормальных классов инициализируются с использованием одного из конструкторов. Но нужно уточнить, что перед вызовом непосредственно конструктора класса, должны быть инициализированы все его поля. Это должно быть понятно, ведь поля можно использовать внутри конструктора класса. Использовать неинициализированные объекты нельзя, так что все поля класса должны быть инициализировани ещё \textit{до входа в конструктор}.
\begin{lstlisting}
#include <iostream>
#include <string>

class Cat
{
private:
	std::string name;
public:	
	Cat() 
	{
		// Тут уже можно использовать поле name. Значит name уже инициализировано.
		name.push_back('A');
		std::cout << name << std::endl;
	}
};

int main()
{
	Cat c;  // Cначала будет инициализировано поле name, а потом вызовется конструктор
}
\end{lstlisting}

\subsection*{Инициализация полей при объявлении внутри класса}
Как инициализируются поля класса? По умолчанию поля класса инициализируются с помощью default инициализации. Но вид инициализации можно задать прямо внутри класса. Правда, это как раз один из тех случаев, когда компилятор не может отличить инициализацию с использованием круглых скобок и объявление функции. То есть в этом случаи можно инициализировать только через знак равенства или фигурные скобки.
\begin{lstlisting}
class Cat
{
private:
	int x;      // Default инициализация
	int y{};    // Value инициализация
	int z{10};  // Direct инициализация
	int w = 10; // Copy инициализация
public:	
	Cat() 
	{
		std::cout << x << std::endl;  // Напечатает произвольное значение
		std::cout << y << std::endl;  // Напечатает 0
		std::cout << z << std::endl;  // Напечатает 10
		std::cout << w << std::endl;  // Напечатает 10
	}
};
\end{lstlisting}

\subsection*{Списки инициализации полей класса}
Другой способ инициализировать поля класса -- это использование так называемых списков инициализации.\\ В этом случае, список инициализации следует за двоеточием после объявления конструктора:
\begin{lstlisting}
class Cat
{
private:
	int age;
	std::string name;
public:	
	Cat() : name("Alice"), age(10) 
	{
		std::cout << name << " " << age << std::endl;  // Напечатает Alice 10
	}
	
	Cat(std::string x, int y) : name(x), age(y)
	{
		std::cout << name << " " << age << std::endl;  // Напечатает значения, 
												       // переданные в конструктор
	}
};
\end{lstlisting}
Списки инициализации -- это единственный способ инициализировать поле, если его значение должно зависить от аргументов конструктора. Могут возникнуть следующие вопросы:

\begin{itemize}
\item Что если поле инициализировано при объявлении внутри класса и в списке инициализации? Какое из значений будет выбрано для инициализации класса? Ответ -- будет выбрано значение из списка инициализации.
\item В каком порядке происходит инициализация полей класса: в том порядке, в котором они объявлены в классе, или в порядке, заданном в списке инициализации? Ответ -- в том порядке, в котором они объявлены в классе. Например, в примере выше, всегда сначала будет инициализироваться поле \texttt{age}, а потом поле \texttt{name}, даже несмотря но то, что в списках инициализации они идут в обратном порядке.
\end{itemize}


\newpage
\section*{Особые методы}
\noindent \textbf{Особые методы класса} (англ. special member functions) -- это методы, которые будут автоматически созданы компилятором, если они не были объявлены программистом. То есть, даже если вы не написали у класса такой метод, он всё-равно будет сгенерирован автоматически.\\
В C++ есть всего 6 особых методов. Рассмотрим их на примере класса \texttt{Cat}.

\begin{enumerate}
\item Конструктор по умолчанию: \texttt{Cat()}\\
Если вы не напишите ни один конструктор в классе, то компилятор сам сгенирирует конструктор по умолчанию. Этот сгенерированный конструктор по умолчанию будет эквивалентен пустому конструктору по умолчанию.

\item Конструктор копирования: \texttt{Cat(const Cat\& x)}\\
Если вы не напишите конструктор копирования, то компилятор сам сгенирирует конструктор копирования. Этот сгенерированный конструктор копирования будет поэлементно копировать все поля класса.

\item Оператор присваивания: \texttt{Cat\& operator=(const Cat\& x)}\\
Если вы не напишите оператор присваивания, то компилятор сам сгенирирует оператор присваивания. Этот сгенерированный оператор присваивания будет поэлементно присваивать все поля класса.

\item Деструктор: \texttt{\mytilde Cat()}\\
Если вы не напишите деструктор, то компилятор сам сгенирирует деструктор. Этот сгенерированный деструктор будет эквивалентен пустому деструктору.
\end{enumerate}

\begin{minipage}[t]{0.45\textwidth}
Если вы написали такой класс:
\begin{lstlisting}
class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
};
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
Компилятор будет считать, что класс выглядит так:
\begin{lstlisting}
class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
	
	// Следующие методы будут 
	// сгенерированы автоматически:
	Cat(const Cat& x) 
		: name(x.name), age(x.age) {}
		
	Cat& operator=(const Cat& x) 
	{
		name = x.name;
		age = x.age;
	}
	
	~Cat() {}
};
\end{lstlisting}
\end{minipage}\\
Обратите внимание, что в данном примере конструктор по умолчанию не был сгенерирован, так как у класса изначально был написан конструктор. Конструктор по умолчанию генерируется только тогда, когда не был написан \textit{ни один} конструктор.

\newpage
\subsection*{Пример создания особых методов компилятором}
Рассмотрим пример, когда компилятор автоматически создаёт особые методы.
Предположим, что мы создали класс и написали в нём один (не особый) конструктор.
В этом случае компилятор автоматически сгенерирует конструктор копирования, оператор присваивания и деструктор. Конструктор по умолчанию автоматически сгенерирован не будет, так как в классе был написан один конструктор.
\begin{lstlisting}
#include <iostream>
#include <string>

class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
};

int main()
{
	Cat a{"Alice", 10};  // OK, вызовется написанный нами конструктор
	Cat b;               // Ошибка, конструктора по умолчанию нет и он не был сгенерирован
	Cat c{a};            // OK, конструктор копирования мы не написали, но он был сгенерирован
						 // компилятором автоматически.

	Cat d{"Bob", 20};    // OK, вызовется написанный нами конструктор
	d = a;               // OK, оператор присваивания мы не написали, но он был сгенерирован,
						 // компилятором автоматически.
}
\end{lstlisting}
\subsection*{Удалённые функции}
Любую функцию или метод можно сделать удалёнными с помощью ключевого слова \texttt{delete}. При попытке вызова такой функции произойдёт ошибка компиляции. Такие функции можно, например, применять, чтобы запретить один из вариантов перегрузки:
\begin{lstlisting}
#include <iostream>

void func(int x)  {std::cout << "Int"  << std::endl;}
void func(double x) = delete;

int main()
{
	func(10);   // OK, напечатает Int
	func(1.5);  // Ошибка компиляции, если бы удалённой функции с параметром double не было бы,
	            // то напечатал бы Int
}
\end{lstlisting}

\newpage
Удалённые функции можно использовать, чтобы запретить компилятору создавать те или иные особые методы.
Например, можно удалить конструктор копирования, что предотвратит автоматическую генерацию этого конструктора компилятором. В результате получится класс, объекты которого нельзя будет копировать. Может показаться, что такая возможность никогда не пригодиться, но это не так. На самом деле, в стандартной библиотеке C++ и в других библиотеках есть множество классов, объекты которых нельзя копировать.

\begin{lstlisting}
#include <iostream>
#include <string>

class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
		
	Cat(const Cat& c) = delete;
};

void func(Cat c) {}

int main()
{
	Cat a{"Alice", 10};  // OK, вызовется написанный нами конструктор
	Cat b{a};            // Ошибка, конструктор копирования удалён
	Cat c = a;           // Ошибка, конструктор копирования удалён
	func(a);             // Ошибка, конструктор копирования удалён
}
\end{lstlisting}

\subsection*{\texttt{default}-методы}
В противоположность удаления особых методов, можно указать компиляторы, что мы хотим генерировать те или иные особые методы автоматически. Для этого используется ключевое слово \texttt{default}.
\begin{lstlisting}
class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
		
	Cat() = default;			  // Просим компилятор сгенерировать этот конструктор
	Cat(const Cat& c) = default;  // Просим компилятор сгенерировать этот конструктор.
	                              // Хотя он и так бы сгенерировал его.
};
\end{lstlisting}
В примере выше строка \texttt{Cat(\textcolor{blue}{const} Cat\& c) = \textcolor{blue}{default};} не изменяет поведение программы, так как конструктор копирования всё-равно бы сгенерировался автоматически, даже без этой строки. Но всё-равно прописывать такие \texttt{default} особые методы полезно, так как это делает код более ясным. 

\section*{Создание объектов в куче}
\subsection*{Операторы \texttt{new}/\texttt{delete}}
Для выделения/освобождения памяти в куче в языке C используются функции \texttt{malloc} и \texttt{free}. Эти функции можно использовать и в языке C++ для выделения памяти. Но эти функции не очень подходят для создания и удаления объектов в куче. Ведь \texttt{malloc} просто выделяет память, но не инициализирует объект, и, следовательно, не вызывает конструктор объекта. А использование объекта нормального класса без вызова конструктора приведёт к UB. Аналогично, функция \texttt{free} просто освобождает память, но не вызывает деструктор.
\begin{lstlisting}
#include <cstdlib>
#include <string>

int main()
{
	std::string* p = (std::string*)std::malloc(sizeof(std::string));
	*p = "Cat";    // UB, так как объект std::string в куче не был инициализован
	std::free(p);
}
\end{lstlisting}

Вместо использования функций \texttt{malloc}/\texttt{free} для создания объектов в куче следует использовать операторы \texttt{new}/\texttt{delete}. С помощью оператора \texttt{new} можно создать объект в куче и корректно его инициализировать. Тогда как с помощью оператора \texttt{delete} можно корректно удалить объект в куче.
\begin{itemize}
\item Оператор \texttt{new} делает следующее:
\begin{enumerate}
\item Выделяет необходимое для объекта количество памяти в куче. Для этого внутри себя \texttt{new} вызывает функцию \texttt{malloc}.
\item Инициализирует объект. Если объект является нормальным классом, то вызывает соответствующий конструктор.
\end{enumerate}
\item Оператор \texttt{delete} делает следующее:
\begin{enumerate}
\item Деинициализирует объект. Вызывает деструктор, если объект является классом.
\item Освобождает выделенную память. Для этого внутри себя \texttt{delete} вызывает функцию \texttt{free}.
\end{enumerate}
\end{itemize}
Пример выше с использованием \texttt{new}/\texttt{delete} перепишется так:
\begin{lstlisting}
#include <string>

int main()
{
	std::string* p = new std::string;  // Выделит память и вызовет конструктор по умолчанию
	*p = "Cat";                        // OK, объект std::string в куче инициализован
	delete p;                          // Вызовет деструктор и освободит память.
}
\end{lstlisting}
Синтаксис разных видов инициализации работает и при использовании оператора \texttt{new}.
За исключением того, что в этом случае не используется copy инициализация.
\begin{lstlisting}
int main()
{
	int* pa = new int;      // Default инициализация, *pa будет иметь произвольное значение
	int* pb = new int{};    // Value инициализация, *pb будет равно нулю
	int* pc = new int(10);  // Direct инициализация, *pc будет равно 10
	int* pd = new int{10};  // Direct инициализация, *pd будет равно 10
	
	delete pa; delete pb; delete pc; delete pd;
}
\end{lstlisting}

\subsection*{Операторы \texttt{new[]}/\texttt{delete[]}}
Помимо операторов \texttt{new}/\texttt{delete} в языке также существуют операторы \texttt{new[]}/\texttt{delete[]}, которые нужны для создания массива объектов в куче.
\begin{lstlisting}
int main()
{
	int* pa = new int[5];    // Выделяем 5 элементов в куче и default-инициализируем их
							 // Элементы будут иметь произвольные значения
							 
	int* pb = new int[5]{};  // Выделяем 5 элементов в куче и value-инициализируем их
							 // Элементы будут равны нулю
	
	
	int* pc = new int[5]{10, 20, 30, 40, 50}; // Выделяем 5 элементов в куче и
	                                          // direct-инициализируем их значениями
	
	
	delete[] pa; 
	delete[] pb; 
	delete[] pc;
}
\end{lstlisting}
Интересно отметить, что так как default инициализация не инициализирует объекты скалярных типов, то операторы \texttt{new} или \texttt{new[]} в случаи скалярных типов с инициализацией по умолчанию будут просто выделять память, то есть делать то же самое, что и \texttt{malloc}.
\begin{lstlisting}
#include <cstdlib>
int main()
{
	// В данном случае операторы new/delete делают то же самое, что и аналогичные malloc/free
	int* pa = new int[5];
	delete[] pa;
	
	int* pb = (int*)std::malloc(5 * sizeof(int));
	std::free(pb);
}
\end{lstlisting}
Важно не путать пары операторов \texttt{new}/\texttt{delete} и \texttt{new[]}/\texttt{delete[]}. Первая пара используется для создания/удаления одного объекта в куче, а вторая пара - для создания/удаления массива объектов. Для удаления объекта, созданного с помощью \texttt{new} нужно использовать только \texttt{delete}, а для удаления массива объектов нужно использовать только \texttt{delete[]}. Если перепутаете, то в программе будет UB.

\begin{lstlisting}
int main()
{
	int* pa = new int[5];  // Создаём массив объектов, используя оператор new[]
	delete pa;             // UB. Так как используем оператор delete, 
	                       // а нужно было использовать delete[].

}
\end{lstlisting}

\newpage
\section*{Статические поля и методы}
\textbf{Статическое поле} -- это поле класса, которое принадлежит самому классу, а не конкретному объекту этого класса. Такие поля не хранятся в объектах класса. Вместо этого хранится единственная копия этого поля в сегменте памяти данные. Получить доступ к этому полю можно либо через имя класса с использованием оператора \texttt{::} либо через объект с использованием оператора точка.
\begin{lstlisting}
#include <iostream>

struct Cat
{
	static int x;
	
	Cat()
	{
		x += 1;
	}
};

int Cat::x = 10;  // Инициализируем статическое поле.

int main()
{
	Cat a;
	Cat b;
	Cat c;
	
	std::cout << Cat::x << std::endl;  // Напечатает 13
	std::cout << a.x << std::endl;     // Напечатает 13
}
\end{lstlisting}

Инициализация статических полей класса должна проводиться вне самого класса. Почему статические поля нельзя инициализировать внутри класса? Это более сложный вопрос который мы оставим на следующие семинары. Пока только можно отметить, что если нужно константное статическое поле, то такое поле можно инициализировать внутри класса если добавить ключевое слово \texttt{constexpr}.
\begin{lstlisting}
#include <iostream>

struct Cat
{
	static constexpr int x = 10;  // Сразу инициализируем
};

int main()
{
	Cat a;
	
	std::cout << Cat::x << std::endl;  // Напечатает 10
	std::cout << a.x << std::endl;     // Напечатает 10
}
\end{lstlisting}

\newpage
\noindent \textbf{Статические методы} -- это методы, которые принадлежат самому классу, а не конкретному объекту этого класса. Такие методы не могут использовать нестатические поля и методы класса. Вызвать такой метод можно либо через имя класса с использованием оператора \texttt{::} либо через объект с использованием оператора точка.

\begin{lstlisting}
#include <iostream>

struct Cat
{
	static void say()
	{
		std::cout << "Hello" << std::endl;
	}
};

int main()
{
	Cat a;
	
	Cat::say();  // Напечатает Hello
	a.say();     // Напечатает Hello
}
\end{lstlisting}



\newpage
\section*{Ключевое слово \texttt{auto} и прочее}

\subsection*{Ключевое слово \texttt{auto}}
Ключевое слово \texttt{auto} используется для автоматического вывода типа.
\begin{lstlisting}
#include <string>
int main() 
{
    auto a = 123;   // a будет иметь тип int
    auto b = 4.1;   // b будет иметь тип double
    auto c = 4.1f;  // c будет иметь тип float
    
    auto s1 = "Hello";               // s1 будет иметь тип const char*
    auto s2 = std::string("Hello");  // s2 будет иметь тип std::string
}

\end{lstlisting}


\subsection*{Задачи:}
\begin{itemize}
\item Протестируйте, можно ли использовать \texttt{auto} вместо возвращаемого типа функции. Напишите функцию, которая принимает на вход вектор строк и возвращает строку, которая является результатом конкатенации всех строк. Вместо возвращаемого типа используйте \texttt{auto}.
\item Протестируйте, можно ли создать функцию, которая будет принимать целое число и, в зависимости от этого числа, возвращать значения разных типов. (Если вместо возвращаемого типа используется \texttt{auto}).

\item Протестируйте, можно ли использовать о указатель с помощью \texttt{auto}. Пусть есть такой участок кода:
\begin{lstlisting}
int a = 123;
auto p = &a;
auto* q = &a;
\end{lstlisting}
Какой тип будет у \texttt{p} и \texttt{q}?
\item Функция вычисления факториала, написанная ниже с использованием \texttt{auto} не работает. 
\begin{lstlisting}
auto factorial(int n) 
{
    if (n > 0)
        return n * factorial(n - 1);
    return 1;
}
\end{lstlisting}
Почему? Исправьте эту функцию, не убирая \texttt{auto}.
\end{itemize}



\newpage
\subsection*{Range-based циклы}
Циклы, основанные на диапазоне, предоставляют более простой способ обхода контейнера:
\begin{lstlisting}
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> v {6, 1, 7, 4};
    for (int num : v)
    	std::cout << num << std::endl;    
}
\end{lstlisting}
Для изменения элементов контейнера при обходе нужно использовать ссылки:
\begin{lstlisting}
for (int& num : v)
    num += 1;    
\end{lstlisting}

\subsection*{Задачи:}
\begin{itemize}
\item Проверьте, можно ли использовать ключевое слово \texttt{auto} внутри таких циклов.
\item Пусть у нас есть вектор строк:
\begin{lstlisting}
vector<string> v {"Cat", "Axolotl", "Bear", "Elephant"};
\end{lstlisting}
\begin{itemize}
\item Напишите range-based цикл, который будет печатать все элементы вектора
\item Напишите range-based цикл, который будет добавлять в конец каждой строки символ \texttt{s}.
\end{itemize}

\item Для печати массива целых чисел была написана следующая функция:
\begin{lstlisting}
void print(int array[]) 
{
    for (int num : array)
        std::cout << num << std::endl;
}
\end{lstlisting}
Оказывается, что она не работает. В чём заключается ошибка?
\end{itemize}

\subsection*{Structure binding (структурное связывание)}
Для объявления и инициализации нескольких переменных через агрегатный объект можно использовать так называемое структурное связывания. В коде ниже мы объявляем переменные \texttt{a} и \texttt{b} одной строкой с помощью структурного связывания.
\begin{lstlisting}
#include <iostream>
struct Point
{
	int x;
	int y;
};
int main() 
{
    Point p {5, 1};
    auto [a, b] = p;
    
    std::cout << a << " " << b << std::endl;
}
\end{lstlisting}

\section*{Основы обработки ошибок с помощью исключений}

\end{document}