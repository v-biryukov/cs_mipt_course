\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1.5cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{listings}
\usepackage{makecell}
\pagenumbering{gobble}

\lstdefinestyle{csMiptCppStyle}{
  language=C++,
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  texcl=true,
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,      
  numbersep=10pt,
  backgroundcolor=\color{white},
  showstringspaces=false,
  captionpos=b,
  breaklines=true
  breakatwhitespace=true,
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
  tabsize=4,
  upquote=true,
}
\lstdefinestyle{csMiptCppBorderStyle}{
  style=csMiptCppStyle,
  framexleftmargin=5mm, 
  frame=shadowbox, 
  rulesepcolor=\color{gray}
}

\lstset{style=csMiptCppStyle}
\lstset{literate={~}{{\raisebox{0.5ex}{\texttildelow}}}{1}}
\newcommand{\mytilde}{\raisebox{0.5ex}{\texttildelow}}


\begin{document}

\title{Семинар \#3: Инициализация. Обработка ошибок.\vspace{-5ex}}\date{}\maketitle

\section*{Инициализация}

\textbf{Инициализация} -- это процесс присвоения начального значения переменной или объекту при их создании.

\subsection*{Инициализация в языке C}
Прежде чем углубляться в инициализацию в языке C++, давайте рассмотрим, как она реализована в языке C.
\begin{itemize}
\item По умолчанию объекты, созданные в сегментах стек и куча, не инициализируются. После создания объекта в них могут находиться произвольные значения:
\begin{lstlisting}
int a;      // a может иметь произвольное значение
int b[5];   // Элементы массива b могут иметь произвольные значения
Book c;     // Элементы структуры c могут иметь произвольные значения
\end{lstlisting}
\item Обычные переменные инициализируются с помощью знака равенства (\texttt{=}).
\begin{lstlisting}
int a = 10;
\end{lstlisting}
\item Массивы и структуры инициализируются с помощью знака равенства и фигурных скобок:
\begin{lstlisting}
int b[5] = {10, 20, 30, 40, 50};
Book c = {"Harry potter", 1000};
\end{lstlisting}
\item Инициализация происходит путём простого задания байтов объекта соответствующими значениями.
\end{itemize}

\subsection*{Инициализация в языке C++}
В C++ инициализация объектов усложняется из-за того, что в языке появляются классы, а объекты классов обычно инициализируются с вызовом конструктора. Для того чтобы разобраться как происходит инициализация объектов разных типов разделим типы C++ на следующие группы:
\begin{enumerate}
\item \textbf{Скалярные типы} -- это все числовые типы (как целочисленные, так и типы с плавающей точкой), булевый тип, указатели, а также перечисления.
\item \textbf{Агрегатные типы} -- к этой группе относятся:
\begin{itemize}
\item Массивы
\item Агрегатные классы. Это классы у которых нет ничего из перечисленного:
\begin{enumerate}
\item конструкторов (за исключением тех, что создаются автоматически)
\item приватных полей
\item виртуальных функций (виртуальных функций будут пройдены в курсе позже)
\end{enumerate}
\end{itemize}
\item \textbf{Нормальные классы} -- к этой группе относятся классы, которые не являются агрегатными.
\end{enumerate}
Такое разделение типов на группы позволяет лучше понять, что происходит при инициализации объектов, так как типы из разных групп инициализируются по-разному.

\begin{itemize}
\item Скаляры инициализируются посредством побайтового задания соответствующих значений.
\item Нормальные классы инициализируются посредством вызова соответствующего конструктора.
\item Агрегаты инициализируются поэлементно. Причём элементом объекта агрегатного типа может быть как скаляр, так и класс или другой агрегат. Для инициализации элементов агрегата применяются те же правила. То есть, если элемент агрегата является скаляром, то он инициализируются побайтово, если элемент агрегата является нормальным классом -- то через конструктор, а если элемент агрегата является другим агрегатом, то поэлементно.
\end{itemize}

\newpage
Можно выделить 4 разных вида инициализации: \textit{default-}, \textit{value-}, \textit{direct-} и \textit{copy-инициализация}. Разные виды инициализации различаются синтаксисом, который вызывает ту или иную инициализацию, а так же тем, что происходит во время этой инициализации. Инициализация может отличаться в зависимости от вида инициализации и инициализируемого типа. Можно составить следующую таблицу:\\

{\renewcommand{\arraystretch}{1.6}
\begin{tabular}{ m{1.9cm} | m{3.3cm}| m{3.5cm} | m{3.2cm}| m{3.2cm} } 
  \hline
   & Синтаксис & Скаляры & Агрегаты & Норм. Классы\\ 
  \hline
  \textit{Default initialization} & \makecell{\texttt{T x;}} & не инициализируются & \textit{Default initialization} для всех элементов & Конструктор по умолчанию \\ 
  
  \hline
   \textit{Value initialization} &\makecell{\texttt{T();}\\ \texttt{T x\{\};}} & инициализируются нулями & \textit{Value initialization} для всех элементов & Конструктор по умолчанию \\ 
  \hline
  
   \textit{Direct initialization} & \makecell{\texttt{T x(a);}\\ \texttt{T x\{a\};} \\ \texttt{T x(a, b, ...);}\\  \texttt{T x\{a, b, ...\};}}& инициализируются соответствующими значениями & \textit{Copy initialization} для всех элементов & Соответствующий конструктор \\ 
  \hline
  
    \textit{Copy initialization} & \makecell{\texttt{T x = a;} \\ \texttt{T x = \{a\};} \\ \texttt{T x = \{a, b, ...\};}\\ \texttt{func(a);}\\ \texttt{return a;}\\  \texttt{func(\{a, b, ...\});} \\ \texttt{return \{a, b, ...\};}}& инициализируются соответствующими значениями & \textit{Copy initialization} для всех элементов & Соответствующий не \texttt{explicit} конструктор \\ 
  \hline
\end{tabular}
}\\
\quad\\
Следует отметить, что эта таблица является неполной, существует ещё варианты синтаксиса когда вызывается та или иная инициализация. Но, тем не менее, эта таблица охватывает большинство случаев инициализации объектов в C++. Также, нужно отметить, что всё вышеперечисленное не относится к ссылкам. Ссылки инициализиуются по другим правилам, которые, правда, являются интуитивно понятными.

К сожалению, в некоторых случаях инициализация с использованием круглых скобок не будет работать, поскольку компилятор может испытывать трудности в различении между инициализацией и объявлением функции.


\subsection*{Примеры инициализации объектов в C++}
Примеры инициализации объекта скалярного типа \texttt{int}:
\begin{lstlisting}
int a;          // Default инициализация - a будет иметь произвольное значение
int b{};        // Value инициализация - b будет равно нулю
int c(10);      // Direct инициализация - c будет равно 10
int d{10};      // Direct инициализация - d будет равно 10
int e = 10;     // Copy инициализация - e будет равно 10
int f = int();  // int() - создаём временный объект типа int с помощью value инициализации,
                // затем инициализируем объект a, используя copy инициализацию 
                // f будет равен нулю
\end{lstlisting}
Примеры инициализации нормального класса \texttt{Cat}. Предположим, что у класса \texttt{Cat} есть конструктор по умолчанию и конструктор, принимающий один аргумент типа \texttt{int}.
\begin{lstlisting}
Cat a;          // Default инициализация - вызовется конструктор по умолчанию
Cat b{};        // Value инициализация - вызовется конструктор по умолчанию
Cat c(10);      // Direct инициализация - вызовется соответствующий конструктор
Cat d{10};      // Direct инициализация - вызовется соответствующий конструктор
Cat e = 10;     // Copy инициализация - вызовется соответствующий конструктор, но только если
                // этот конструктор НЕ является explicit. Если же соответствующий конструктор 
                // является explicit, то будет ошибка компиляции
\end{lstlisting}

\newpage


\subsection*{\texttt{explicit} конструкторы}
Любой конструктор можно пометить как \texttt{explicit} (\texttt{explicit} можно перевести как \textit{явный}). Такие конструкторы нельзя использовать для copy-инициализации. 
\begin{lstlisting}
#include <iostream>
#include <string>

struct Cat
{
	int x;
	explicit Cat(int x) 
	{
		std::cout << "Cat Constructor" << std::endl;
		this->x = x;
	}
};

void func(Cat c) {}

int main()
{
	Cat a(10);  // OK, explicit конструктор можно использовать для direct-инициализации
	Cat b = 10; // Ошибка, explicit конструктор нельзя использовать для copy-инициализации
	func(10);   // Ошибка, explicit конструктор нельзя использовать для copy-инициализации
}
\end{lstlisting}

\subsection*{Инициализация полей классов}
Объекты нормальных классов инициализируются с использованием одного из конструкторов. Но нужно уточнить, что перед вызовом непосредственно конструктора класса, должны быть инициализированы все его поля. Это должно быть понятно, ведь поля можно использовать внутри конструктора класса. Использовать неинициализированные объекты нельзя, так что все поля класса должны быть инициализировани ещё \textit{до входа в конструктор}.
\begin{lstlisting}
#include <iostream>
#include <string>

class Cat
{
private:
	std::string name;
public:	
	Cat() 
	{
		// Тут уже можно использовать поле name. Значит name уже инициализировано.
		name.push_back('A');
		std::cout << name << std::endl;
	}
};

int main()
{
	Cat c;  // Cначала будет инициализировано поле name, а потом вызовется конструктор
}
\end{lstlisting}

\subsection*{Инициализация полей при объявлении внутри класса}
Как инициализируются поля класса? По умолчанию поля класса инициализируются с помощью default инициализации. Но вид инициализации можно задать прямо внутри класса. Правда, это как раз один из тех случаев, когда компилятор не может отличить инициализацию с использованием круглых скобок и объявление функции. То есть в этом случаи можно инициализировать только через знак равенства или фигурные скобки.
\begin{lstlisting}
class Cat
{
private:
	int x;      // Default инициализация
	int y{};    // Value инициализация
	int z{10};  // Direct инициализация
	int w = 10; // Copy инициализация
public:	
	Cat() 
	{
		std::cout << x << std::endl;  // Напечатает произвольное значение
		std::cout << y << std::endl;  // Напечатает 0
		std::cout << z << std::endl;  // Напечатает 10
		std::cout << w << std::endl;  // Напечатает 10
	}
};
\end{lstlisting}

\subsection*{Списки инициализации полей класса}
Другой способ инициализировать поля класса -- это использование так называемых списков инициализации.\\ В этом случае, список инициализации следует за двоеточием после объявления конструктора:
\begin{lstlisting}
class Cat
{
private:
	int age;
	std::string name;
public:	
	Cat() : name("Alice"), age(10) 
	{
		std::cout << name << " " << age << std::endl;  // Напечатает Alice 10
	}
	
	Cat(std::string x, int y) : name(x), age(y)
	{
		std::cout << name << " " << age << std::endl;  // Напечатает значения, 
												       // переданные в конструктор
	}
};
\end{lstlisting}
Списки инициализации -- это единственный способ инициализировать поле, если его значение должно зависить от аргументов конструктора. Могут возникнуть следующие вопросы:

\begin{itemize}
\item Что если поле инициализировано при объявлении внутри класса и в списке инициализации? Какое из значений будет выбрано для инициализации класса? Ответ -- будет выбрано значение из списка инициализации.
\item В каком порядке происходит инициализация полей класса: в том порядке, в котором они объявлены в классе, или в порядке, заданном в списке инициализации? Ответ -- в том порядке, в котором они объявлены в классе. Например, в примере выше, всегда сначала будет инициализироваться поле \texttt{age}, а потом поле \texttt{name}, даже несмотря но то, что в списках инициализации они идут в обратном порядке.
\end{itemize}


\newpage
\section*{Особые методы}
\noindent \textbf{Особые методы класса} (англ. special member functions) -- это методы, которые будут автоматически созданы компилятором, если они не были объявлены программистом. То есть, даже если вы не написали у класса такой метод, он всё-равно будет сгенерирован автоматически.\\
В C++ есть всего 6 особых методов. Рассмотрим их на примере класса \texttt{Cat}.

\begin{enumerate}
\item Конструктор по умолчанию: \texttt{Cat()}\\
Если вы не напишите ни один конструктор в классе, то компилятор сам сгенирирует конструктор по умолчанию. Этот сгенерированный конструктор по умолчанию будет эквивалентен пустому конструктору по умолчанию.

\item Конструктор копирования: \texttt{Cat(const Cat\& x)}\\
Если вы не напишите конструктор копирования, то компилятор сам сгенирирует конструктор копирования. Этот сгенерированный конструктор копирования будет поэлементно копировать все поля класса.

\item Оператор присваивания: \texttt{Cat\& operator=(const Cat\& x)}\\
Если вы не напишите оператор присваивания, то компилятор сам сгенирирует оператор присваивания. Этот сгенерированный оператор присваивания будет поэлементно присваивать все поля класса.

\item Деструктор: \texttt{\mytilde Cat()}\\
Если вы не напишите деструктор, то компилятор сам сгенирирует деструктор. Этот сгенерированный деструктор будет эквивалентен пустому деструктору.
\end{enumerate}

\begin{minipage}[t]{0.45\textwidth}
Если вы написали такой класс:
\begin{lstlisting}
class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
};
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
Компилятор будет считать, что класс выглядит так:
\begin{lstlisting}
class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
	
	// Следующие методы будут 
	// сгенерированы автоматически:
	Cat(const Cat& x) 
		: name(x.name), age(x.age) {}
		
	Cat& operator=(const Cat& x) 
	{
		name = x.name;
		age = x.age;
	}
	
	~Cat() {}
};
\end{lstlisting}
\end{minipage}\\
Обратите внимание, что в данном примере конструктор по умолчанию не был сгенерирован, так как у класса изначально был написан конструктор. Конструктор по умолчанию генерируется только тогда, когда не был написан \textit{ни один} конструктор.

\newpage
\subsection*{Пример создания особых методов компилятором}
Рассмотрим пример, когда компилятор автоматически создаёт особые методы.
Предположим, что мы создали класс и написали в нём один (не особый) конструктор.
В этом случае компилятор автоматически сгенерирует конструктор копирования, оператор присваивания и деструктор. Конструктор по умолчанию автоматически сгенерирован не будет, так как в классе был написан один конструктор.
\begin{lstlisting}
#include <iostream>
#include <string>

class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
};

int main()
{
	Cat a{"Alice", 10};  // OK, вызовется написанный нами конструктор
	Cat b;               // Ошибка, конструктора по умолчанию нет и он не был сгенерирован
	Cat c{a};            // OK, конструктор копирования мы не написали, но он был сгенерирован
						 // компилятором автоматически.

	Cat d{"Bob", 20};    // OK, вызовется написанный нами конструктор
	d = a;               // OK, оператор присваивания мы не написали, но он был сгенерирован,
						 // компилятором автоматически.
}
\end{lstlisting}
\subsection*{Удалённые функции}
Любую функцию или метод можно сделать удалёнными с помощью ключевого слова \texttt{delete}. При попытке вызова такой функции произойдёт ошибка компиляции. Такие функции можно, например, применять, чтобы запретить один из вариантов перегрузки:
\begin{lstlisting}
#include <iostream>

void func(int x)  {std::cout << "Int"  << std::endl;}
void func(double x) = delete;

int main()
{
	func(10);   // OK, напечатает Int
	func(1.5);  // Ошибка компиляции, если бы удалённой функции с параметром double не было бы,
	            // то напечатал бы Int
}
\end{lstlisting}

\newpage
\noindent Удалённые функции можно использовать, чтобы запретить компилятору создавать те или иные особые методы.
Например, можно удалить конструктор копирования, что предотвратит автоматическую генерацию этого конструктора компилятором. В результате получится класс, объекты которого нельзя будет копировать. Может показаться, что такая возможность никогда не пригодиться, но это не так. На самом деле, в стандартной библиотеке C++ и в других библиотеках есть множество классов, объекты которых нельзя копировать.

\begin{lstlisting}
#include <iostream>
#include <string>

class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
		
	Cat(const Cat& c) = delete;
};

void func(Cat c) {}

int main()
{
	Cat a{"Alice", 10};  // OK, вызовется написанный нами конструктор
	Cat b{a};            // Ошибка, конструктор копирования удалён
	Cat c = a;           // Ошибка, конструктор копирования удалён
	func(a);             // Ошибка, конструктор копирования удалён
}
\end{lstlisting}

\subsection*{\texttt{default}-методы}
В противоположность удаления особых методов, можно указать компилятору, что мы хотим генерировать те или иные особые методы автоматически. Для этого используется ключевое слово \texttt{default}.
\begin{lstlisting}
class Cat
{
private:
	std::string name;
	int age;
	
public:
	Cat(std::string name, int age) 
		: name(name), age(age) {}
		
	Cat() = default;			  // Просим компилятор сгенерировать этот конструктор
	Cat(const Cat& c) = default;  // Просим компилятор сгенерировать этот конструктор.
	                              // Хотя он и так бы сгенерировал его.
};
\end{lstlisting}
В примере выше строка \texttt{Cat(\textcolor{blue}{const} Cat\& c) = \textcolor{blue}{default};} не изменяет поведение программы, так как конструктор копирования всё равно бы был сгенерирован автоматически, даже без этой строки. Но всё-равно прописывать такие \texttt{default} особые методы полезно, так как это делает код более ясным. 

\section*{Создание объектов в куче}
\subsection*{Операторы \texttt{new}/\texttt{delete}}
Для выделения/освобождения памяти в куче в языке C используются функции \texttt{malloc} и \texttt{free}. Эти функции можно использовать и в языке C++ для выделения памяти. Но эти функции не очень подходят для создания и удаления объектов в куче. Ведь \texttt{malloc} просто выделяет память, но не инициализирует объект, и, следовательно, не вызывает конструктор объекта. А использование объекта нормального класса без вызова конструктора приведёт к UB. Аналогично, функция \texttt{free} просто освобождает память, но не вызывает деструктор.
\begin{lstlisting}
#include <cstdlib>
#include <string>

int main()
{
	std::string* p = (std::string*)std::malloc(sizeof(std::string));
	*p = "Cat";    // UB, так как объект std::string в куче не был инициализован
	std::free(p);
}
\end{lstlisting}
Вместо использования функций \texttt{malloc}/\texttt{free} для создания объектов в куче следует использовать операторы \texttt{new}/\texttt{delete}. С помощью оператора \texttt{new} можно создать объект в куче и корректно его инициализировать. Тогда как с помощью оператора \texttt{delete} можно корректно удалить объект в куче.
\begin{itemize}
\item Оператор \texttt{new} делает следующее:
\begin{enumerate}
\item Выделяет необходимое для объекта количество памяти в куче. Для этого внутри себя \texttt{new} вызывает функцию \texttt{malloc}.
\item Инициализирует объект. Если объект является нормальным классом, то вызывает соответствующий конструктор.
\end{enumerate}
\item Оператор \texttt{delete} делает следующее:
\begin{enumerate}
\item Деинициализирует объект. Вызывает деструктор, если объект является классом.
\item Освобождает выделенную память. Для этого внутри себя \texttt{delete} вызывает функцию \texttt{free}.
\end{enumerate}
\end{itemize}
Пример выше с использованием \texttt{new}/\texttt{delete} перепишется так:
\begin{lstlisting}
#include <string>
int main()
{
	std::string* p = new std::string;  // Выделит память и вызовет конструктор по умолчанию
	*p = "Cat";                        // OK, объект std::string в куче инициализован
	delete p;                          // Вызовет деструктор и освободит память.
}
\end{lstlisting}
Синтаксис разных видов инициализации работает и при использовании оператора \texttt{new}.
За исключением того, что в этом случае не используется copy инициализация.
\begin{lstlisting}
int main()
{
	int* pa = new int;      // Default инициализация, *pa будет иметь произвольное значение
	int* pb = new int{};    // Value инициализация, *pb будет равно нулю
	int* pc = new int(10);  // Direct инициализация, *pc будет равно 10
	int* pd = new int{10};  // Direct инициализация, *pd будет равно 10
	
	delete pa; delete pb; delete pc; delete pd;
}
\end{lstlisting}

\subsection*{Операторы \texttt{new[]}/\texttt{delete[]}}
Помимо операторов \texttt{new}/\texttt{delete} в языке также существуют операторы \texttt{new[]}/\texttt{delete[]}, которые нужны для создания массива объектов в куче.
\begin{lstlisting}
int main()
{
	int* pa = new int[5];    // Выделяем 5 элементов в куче и default-инициализируем их
							 // Элементы будут иметь произвольные значения
							 
	int* pb = new int[5]{};  // Выделяем 5 элементов в куче и value-инициализируем их
							 // Элементы будут равны нулю
	
	
	int* pc = new int[5]{10, 20, 30, 40, 50}; // Выделяем 5 элементов в куче и
	                                          // direct-инициализируем их значениями
	
	
	delete[] pa; 
	delete[] pb; 
	delete[] pc;
}
\end{lstlisting}
Интересно отметить, что так как default инициализация не инициализирует объекты скалярных типов, то операторы \texttt{new} или \texttt{new[]} в случаи скалярных типов с инициализацией по умолчанию будут просто выделять память, то есть делать то же самое, что и \texttt{malloc}.
\begin{lstlisting}
#include <cstdlib>
int main()
{
	// В данном случае операторы new/delete делают то же самое, что и аналогичные malloc/free
	int* pa = new int[5];
	delete[] pa;
	
	int* pb = (int*)std::malloc(5 * sizeof(int));
	std::free(pb);
}
\end{lstlisting}
Важно не путать пары операторов \texttt{new}/\texttt{delete} и \texttt{new[]}/\texttt{delete[]}. Первая пара используется для создания/удаления одного объекта в куче, а вторая пара - для создания/удаления массива объектов. Для удаления объекта, созданного с помощью \texttt{new} нужно использовать только \texttt{delete}, а для удаления массива объектов нужно использовать только \texttt{delete[]}. Если перепутаете, то в программе будет UB.

\begin{lstlisting}
int main()
{
	int* pa = new int[5];  // Создаём массив объектов, используя оператор new[]
	delete pa;             // UB. Так как используем оператор delete, 
	                       // а нужно было использовать delete[].

}
\end{lstlisting}


\subsection*{Оператор \texttt{placement new}}




\newpage
\section*{Статические поля и методы}
\textbf{Статическое поле} -- это поле класса, которое принадлежит самому классу, а не конкретному объекту этого класса. Такие поля не хранятся в объектах класса. Вместо этого хранится единственная копия этого поля в сегменте памяти данные. Получить доступ к этому полю можно либо через имя класса с использованием оператора \texttt{::} либо через объект с использованием оператора точка.
\begin{lstlisting}
#include <iostream>
struct Cat
{
	static int x;
	
	Cat()
	{
		x += 1;
	}
};

int Cat::x = 10;  // Инициализируем статическое поле.

int main()
{
	Cat a;
	Cat b;
	Cat c;
	
	std::cout << Cat::x << std::endl;  // Напечатает 13
	std::cout << a.x << std::endl;     // Напечатает 13
}
\end{lstlisting}
Инициализация статических полей класса должна проводиться вне самого класса. Почему статические поля нельзя инициализировать внутри класса? Это более сложный вопрос который мы оставим на следующие семинары. Пока только можно отметить, что если нужно константное статическое поле, то такое поле можно инициализировать внутри класса если добавить ключевое слово \texttt{constexpr}.
\begin{lstlisting}
#include <iostream>
struct Cat
{
	static constexpr int x = 10;  // Сразу инициализируем
};

int main()
{
	Cat a;
	
	std::cout << Cat::x << std::endl;  // Напечатает 10
	std::cout << a.x << std::endl;     // Напечатает 10
}
\end{lstlisting}

\newpage
\noindent \textbf{Статические методы} -- это методы, которые принадлежат самому классу, а не конкретному объекту этого класса. Такие методы не могут использовать нестатические поля и методы класса. Вызвать такой метод можно либо через имя класса с использованием оператора \texttt{::} либо через объект с использованием оператора точка.

\begin{lstlisting}
#include <iostream>
struct Cat
{
	static void say()
	{
		std::cout << "Hello" << std::endl;
	}
};
int main()
{
	Cat a;
	
	Cat::say();  // Напечатает Hello
	a.say();     // Напечатает Hello
}
\end{lstlisting}



\section*{Copy elision}


\newpage
\section*{Обработка ошибок}
Есть множество различных классификаций ошибок, здесь представлена одна из них, которая может отличаться от классификаций в других источниках. Ошибки делятся на:
\begin{itemize}
\item Ошибки времени компиляции
\item Ошибки линковки
\item Ошибки времени выполнения
\item Логические ошибки (ошибки в логике работы программы; могут привести или не привести к ошибке времени выполнения)
\end{itemize}
Под обработкой ошибок обычно понимается обработка ошибок времени выполнения. Их, в свою очередь, можно тоже разделить на два типа: внутренние и внешние.
\begin{center}
\includegraphics[scale=0.9]{../images/error_types.png}
\end{center}
Эти два типа ошибок времени выполнения сильно различаются друг от друга и могут обрабатываться различными способами.
\begin{itemize}
\item От внутренних ошибок, как правило, нельзя восстановиться. Лучшее решение в этом случае -- это завершить выполнение программы и вывести сообщение об ошибке.
\item Внешние ошибки часто можно предусмотреть и продумать действия программы при возникновении такой ошибки. Иногда можно даже восстановить работу программы.
\end{itemize}

\newpage
\section*{Методы обработки ошибок}
\subsection*{\texttt{assert}}
\texttt{assert} обычно используется для отладки в Debug режиме, но иногда его применяют и для примитивной отладки ошибок. В случае, если условие в \texttt{assert} не выполняется, вызывает функцию \texttt{std::abort} и завершает программу. Нет возможности как-то обработать ошибку и продолжить выполнение программы.
\begin{lstlisting}
#include <iostream>
#include <cmath>
#include <cassert>
float geometricMean(float a, float b)
{
    assert(a >= 0 && b >= 0);
    return std::sqrt(a * b);
}

int main()
{
    std::cout << geometricMean(-2, 2) << std::endl;
    std::cout << "After" << std::endl;
}
\end{lstlisting}
Выполнение данной программы напечатает на экран:
\begin{lstlisting}
Assertion failed: a >= 0 && b >= 0, file test2.cpp, line 7
\end{lstlisting}


\subsection*{Использование глобальной переменной}
Обработка ошибок через глобальную переменную \texttt{errno} — простой метод, широко применявшийся в языке C. При возникновении ошибки ей присваивается код (например, \texttt{EDOM}, \texttt{EPERM} и другие), который затем проверяется после вызова функции. Сегодня такой подход считается устаревшим.
\begin{lstlisting}
#include <iostream>
#include <cmath>
#include <cerrno>
float geometricMean(float a, float b)
{
    if (a < 0 || b < 0)
    {    
    	errno = EDOM;
    	return 0;
    }
    return std::sqrt(a * b);
}

int main()
{
    errno = 0;
    float result = geometricMean(-2, 2);
    if (errno == EDOM)
    {
        std::cout << "Error. Domain error!" << std::endl;
        std::exit(1);
    }
    std::cout << "Result = " << result << std::endl;
}

\end{lstlisting}

\subsection*{Коды возврата}
Простой и широко используемый способ обработки ошибок -- возврат заранее оговоренного значения из функции при возникновении ошибки. После вызова функцию, которая использует коды возврата, необходимо проверить на возвращаемое значение. Сложность может возникнуть, если функция уже возвращает значение. Тогда придётся передавать значение или код возврата каким-то другим способом, например через аргументы по ссылке.
\begin{lstlisting}
#include <iostream>
#include <cmath>

int geometricMean(float a, float b, float& result)
{
	if (a < 0 || b < 0)
		return -1;
	result = std::sqrt(a * b);
    return 0;
}

int main()
{
    float result;
    int code = geometricMean(-2, 2, result);
    if (code == -1)
    	std::cout << "Error!" << std::endl;
    else
    	std::cout << "Result = " << result << std::endl;
}
\end{lstlisting}
Другой способ, это использование специального объекта для хранения и результата и кода ошибки:
\begin{lstlisting}
#include <iostream>
#include <cmath>

struct Result
{
	float value;
	int code;
};

Result geometricMean(float a, float b)
{
	if (a < 0 || b < 0)
		return {0.0, -1};
    return {std::sqrt(a * b), 0};
}

int main()
{
    Result res = geometricMean(-2, 2);
    if (res.code == -1)
    	std::cout << "Error!" << std::endl;
    else
    	std::cout << "Result = " << res.value << std::endl;
}
\end{lstlisting}

\noindent Коды возврата часто применяются как в языке C (можно вспомнить, например, функцию \texttt{malloc}), так и в языке C++. Но в C++ для работы с кодами возврата часто используются вспомогательные классы, такие как \texttt{std::optional} и \texttt{std::expected}.

\subsubsection*{Недостатки кодов возврата}
В целом, коды возврата это хороший способ обработки ошибок, но у него есть несколько недостатков:
\begin{itemize}
\item Самый главный недостаток кодов возврата заключается в том, что для корректной обработки ошибок необходимо делать проверку кода возврата \textit{после каждого вызова функции}. В результате весь код превращается в "лапшу"{} и проверок. Такой код сложно писать и поддерживать.
\item Если ошибка возникает глубоко в коде, а обрабатываться должна выше, её приходится "прокидывать"{} через все вложенные функции. Что также усложняет написание и поддержку кода.
\item Нельзя обработать ошибки в некоторых функциях, таких как конструкторы, деструкторы или перегруженные операторы.
\end{itemize}

\subsection*{Исключения}
Исключения -- это основной механизм обработки ошибок в C++. Использование исключений позволяет отделить код обнаружения ошибки от её обработки.
\begin{lstlisting}
#include <iostream>
#include <cmath>
#include <stdexcept>

float geometricMean(float a, float b)
{
    if (a < 0 || b < 0)
        throw std::runtime_error{"Domain error"};
    return std::sqrt(a * b);
}

int main()
{
    try
    {
        std::cout << geometricMean(-2, 2) << std::endl;
    }
    catch (std::runtime_error& e)
    {
        std::cout << "Error. " << e.what() << std::endl;
    }
}
\end{lstlisting}
\begin{itemize}
\item При обнаружении исключения "бросаем"{} объект, используя ключевое слово \texttt{throw}. В качестве бросаемого объекта может быть объект практически любого типа, но обычно используются специальные типы из библиотеки \texttt{stdexcept}, такие как, например, \texttt{std::runtime\_error}.

\item Код, в котором могут возникнуть ошибки помещаем в блок \texttt{try}.

\item Если внутри \texttt{try} (включая вызванные из него функции) будет выброшено исключение, и существует блок \texttt{catch} с совместимым типом, управление передаётся в этот \texttt{catch}. При переходе объекты, созданные в \texttt{try}, корректно уничтожаются.

\item Одному блоку \texttt{try} могут соответствовать несколько блоков \texttt{catch}, для обработки нескольких типов ошибок.

\item Метод \texttt{what} класса \texttt{std::runtime\_error} просто возвращает C-строку (\texttt{const char*}), содержащую описание ошибки, заданное при создании объекта. В данном случае это строка \texttt{"Domain error"}. 
\end{itemize}


\newpage
\section*{Основы обработки ошибок с помощью исключений}
\subsection*{Несколько \texttt{catch}-блоков}
Бросать можно объект практически любого типа. При этом тип объекта в блоке \texttt{catch} должен быть совместимым с типом бросаемого объекта, а именно:
\begin{itemize}
\item Тип в \texttt{catch} должен полностью совпадать с типом бросаемого объекта.
\item Тип в \texttt{catch} должен быть ссылкой/константной ссылкой на тип бросаемого объекта.
\item Тип в \texttt{catch} должен быть ссылкой на базовый класс для типа бросаемого объекта. (более подробно этот случай будет разобран в теме "Наследование")
\end{itemize}
Одному блоку \texttt{try} могут соответствовать несколько блоков \texttt{catch}. Для обработки ошибки будет выбран блок \texttt{catch} с совместимым типом. Если подходят несколько блоков, то будет выбран первый \texttt{catch} с совместимым типом.
\begin{lstlisting}
#include <iostream>
int main()
{
    try
    {
        throw 123;
    }
    catch (float x)
    {
        std::cout << "Float: " << x << std::endl;
    }
    catch (long long x)
    {
        std::cout << "Long Long: " << x << std::endl;
    }
    catch (const int& x)
    {
        std::cout << "Const Int Ref: " << x << std::endl;
    }
    catch (int x)
    {
        std::cout << "Int: " << x << std::endl;
    }
}
\end{lstlisting}
В данной программе мы бросаем объект типа \texttt{int} со значением \texttt{123}. Блоки \texttt{catch} с типами \texttt{float} и \texttt{long long} не подойдут. Блоки с типами \texttt{const int\&} и \texttt{int} подходят, но среди них будет выбран первый. В результате программа напечатает:
\begin{lstlisting}
Const Int Ref: 123
\end{lstlisting}

\subsection*{Обработчик \texttt{catch} для любого типа}
Есть специальный обработчик исключений \texttt{catch(...)}, который может перехватывать абсолютно любые типы исключений. Перехватывает исключения любого типа, но с его помощью нельзя получить сам бросаемый объект. 
\begin{lstlisting}
catch (...)
{
	std::cout << "Any Type" << std::endl;
}
\end{lstlisting}



\subsection*{Что происходит при бросании объекта}
Класс \texttt{Verbose} просто печатает сообщение при вызове особого метода. Его можно найти в\\ \texttt{seminar3\_initialization/theory/code/verbose.hpp}.
\begin{lstlisting}
#include <iostream>
#include "verbose.hpp"
int main()
{
    try
    {
        Verbose a{"Alice"};
        throw a;
    }
    catch (Verbose x)
    {
        std::cout << x.getName() << std::endl;
    }
}
\end{lstlisting}
Что напечатает данная программа? А если ловить не по значению, а по ссылке?


\subsection*{Раскрутка стека}


\subsection*{Исключения в деструкторах}


\subsection*{Библиотечные классы для исключений}
\texttt{std::exception}, \texttt{std::runtime\_error} и другие.


\subsection*{Исключения в языке C++. Оператор \texttt{new}.}
Далеко не для всех типов ошибок в C++ используются исключения. Деление на 0. Выход за границы массива, вектора.
Но используется для \texttt{new}. \texttt{std::bad\_alloc}. \texttt{std::nothrow}.


\subsection*{Исключения в стандартной библиотеке C++}
Исключения в \texttt{std::string} и \texttt{std::vector}.
\begin{itemize}
\item \texttt{std::bad\_alloc}
\item \texttt{std::out\_of\_range}
\item \texttt{std::invalid\_argument}
\item \texttt{std::domain\_error}
\end{itemize}



\subsection*{Недостатки исключений}

\begin{itemize}
\item Производительность
\item Усложнение программы
\item Возможность утечки памяти/ресурсов
\end{itemize}


\subsection*{Кратко об использовании исключений при написании своих классов}
Гарантии безопасности. Copy and swap.




\end{document}