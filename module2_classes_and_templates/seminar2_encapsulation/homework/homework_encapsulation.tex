\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1.5cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{caption}

\begin{document}
\pagenumbering{gobble}

\lstset{
  language=C++,
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  texcl=true,
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  %numbers=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,      
  numbersep=10pt,
  backgroundcolor=\color{white},
  showstringspaces=false,
  captionpos=b,
  breaklines=true
  breakatwhitespace=true,
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
  tabsize=4,
  upquote=true,
}
\lstset{ literate={~}{{\raisebox{0.5ex}{\texttildelow}}}{1}}

\renewcommand{\thesubsection}{\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\@ifundefined{#1@cntformat}%
   {\csname the#1\endcsname\quad}%    default
   {\csname #1@cntformat\endcsname}}% enable individual control
\newcommand\section@cntformat{}     % section level 
\newcommand\subsection@cntformat{Задача \thesubsection.\space} % subsection level
\newcommand\subsubsection@cntformat{\thesubsubsection.\space} % subsubsection level
\makeatother

\title{Семинар \#2: Классы и перегрузка операторов. Домашнее задание.\vspace{-5ex}}\date{}\maketitle

\subsection{Класс \texttt{Circle}}
Допустим, что мы хотим создать программу, которая будет работать с окружностями (это может быть игра или, например, графический редактор). Для того, чтобы сделать код более понятным и удобным в использовании, мы решили создать класс окружности. Кроме того, мы решили использовать уже ранее написанный класс точки в 2D пространстве (файл \texttt{point.hpp}). Создайте класс окружности, который будет включать следующие поля:
\begin{itemize}
\item Поле \texttt{center} типа \texttt{Point} -- центр окружности.
\item Поле \texttt{radius} типа \texttt{float} -- радиус окружности.
\end{itemize}

И следующие методы:
\begin{itemize}
\item Конструктор \texttt{Circle(const Point\& center, float radius)}, который будет задавать поля \texttt{center} и \texttt{radius} соответстующими значениями.
\item Конструктор по умолчанию \texttt{Circle()} -- задаются значения, соответствующие единичной окружности с центром в начале координат.
\item Конструктор копирования \texttt{Circle(const Circle\& circle)}
\item Сеттеры и геттеры, для полей \texttt{center} и \texttt{radius}. Поле \texttt{radius} нельзя задать отрицательным числом. При попытке задания его отрицательным числом оно должно устанавливаться в значение \texttt{0}.
\item Метод \texttt{float area() const}, который будет возвращать площадь поверхности круга.
\item Метод \texttt{float distance(const Point\& p) const}, который будет возвращать расстояние от точки \texttt{p}, до ближайшей точки окружности.
\item Метод \texttt{bool isColliding(const Circle\& c) const}, который будет возвращать \texttt{true}, если круг пересекается с кругом \texttt{c}.
\item Метод \texttt{void move(const Point\& p)}, который будет перемещать кружок на вектор \texttt{p}.
\end{itemize}
Весь начальный код содержится в папке \texttt{code/circle}.


\subsection{Математический вектор}
В папке \texttt{code/complex} лежит реализация комплексного числа с перегруженными операторами. Используйте её в качестве примера для решения этой задачи.
\begin{itemize}
\item Создайте класс \texttt{Vector2f} -- вектор в двумерном пространстве с полями \texttt{x} и \texttt{y} типа \texttt{float} в качестве координат. Перегрузите следующие операторы для работы с вектором. Для передачи вектора в функции используте ссылки и, там где возможно, модификатор \texttt{const}.
\begin{itemize}
\item Сложение векторов (\texttt{+})
\item Вычитание (\texttt{-})
\item Умножение вектора на число типа \texttt{float} (число \texttt{*} вектор и вектор \texttt{*} число)
\item Скалярное произведение (\texttt{*})
\item Унарный \texttt{-}
\item Унарный \texttt{+}
\item Проверка на равенство \texttt{==}  (должна возвращать тип \texttt{bool})
\item Проверка на неравенство \texttt{!=}  (должна возвращать тип \texttt{bool})
\item Операторы \texttt{+=} и \texttt{-=}  (вектор \texttt{+=} вектор)
\item Операторы \texttt{*=}  (вектор \texttt{*=} число)
\item Оператор вывода  \texttt{ostream >{}>} вектор. Выводите вектор в виде \texttt{(x, y)}.
\item Оператор ввода  \texttt{istream <{}<} вектор
\end{itemize}
\item Протестируйте ваши функции:
\begin{lstlisting}
#include <iostream>
#include "vector2f.h"
using std::cout, std::endl;

int main() 
{
	Vector2f a = {1.0, 2.0};
	Vector2f b = {4.0, -1.0};
	cout << "a = " << a << endl << "b = " << b << endl;
	cout << "a + b = " << a + b << endl;
	cout << "-a = " << -a << endl;
	cout << "Scalar product of a and b = " << a * b << endl;
	a /= 5;
	cout << "a after a /= 5;"  << a << endl
	a += b;
	cout << "a after a+= b;" << a << endl;
}
\end{lstlisting}

\end{itemize}


\subsection{Большие числа}
Стандартные целочисленные  типы данных, такие как \texttt{int} имеют фиксированный небольшой размер. Соответственно значения, которые можно хранить в переменных этих типов ограничены. Типичное максимальное значение \texttt{char} равно $2^7 - 1 = 127$, тип \texttt{int} обычно ограничен $2^{31}-1 = 2147483647$ и даже тип \texttt{unsigned long long} имеет ограничение в $2^{64}-1 \approx 1.8 * 10^{19}$. Хранить действительно большие числа в этих типах невозможно. В этом задании нужно создать класс, с помощью которого можно будет удобно складывать и умножать большие целые положительные числа. Начальный код этого класса содержится в папке \texttt{code/number}.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{../images/number1.png}
\captionsetup{labelformat=empty}
\caption{Представление числа 12345678 в памяти с помощью нашего класса Number}
\label{fig:nummber1}
\end{figure}


\subsection*{Подзадачи:}
\begin{enumerate}
\item \textbf{Конструктор по умолчанию:} Напишите конструктор по умолчанию \texttt{Number()}, который будет создавать число равное нулю.
\item \textbf{Конструктор копирования:} Напишите конструктор копирования \texttt{Number(const Number\& n)}.
\item \textbf{Конструктор из строки:} Напишите конструктор \texttt{Number(const std::string\& str)}, который будет создавать большое число на основе строки. Предполагаем, что на вход конструктору всегда идёт корректная строка. Например, число из примера можно будет создать так:
\begin{lstlisting}
Number a("12345678");
\end{lstlisting}
или так:
\begin{lstlisting}
Number a = "12345678";
\end{lstlisting}
\item \textbf{Присваивание:} Напишите оператор присваивания \texttt{Number\& operator=(const Number\& n)}.
\item \textbf{Сложение:} Напишите и протестируйте операторы сложения \texttt{operator+} и оператор присваивания сложения \texttt{operator+=}.  Реализовывать оба этих оператора с нуля необязательно. Ведь, если написан один из этих операторов, то очень просто написать другой.
\item \textbf{Числа Фибоначчи:} Числа Фибоначчи задаются следующим образом:
\begin{align*}
F_0 &= 0\\
F_1 &= 1\\
F_n &= F_{n-1} + F_{n-2}
\end{align*}
Используйте класс \texttt{Number}, чтобы вычислить $F_{1000}$. Правильный ответ:
\begin{verbatim}
F(1000) = 43466557686937456435688527675040625802564660517371780402481729089536555417949051890
40387984007925516929592259308032263477520968962323987332247116164299644090653318793829896964992
8516003704476137795166849228875
\end{verbatim}


\item \textbf{Четность:} Напишите метод \texttt{bool isEven() const}, который будет проверять является ли наше число чётным и, если это верно, возвращает \texttt{true}, в ином случае возвращает \texttt{false}.

\item \textbf{Произведение:} Напишите метод \texttt{Number operator*(const Number\& n) const} - оператор умножения одного числа \texttt{Number} на другое. Протестируйте вашу функцию на различных примерах (умножение большого числа на большое, умножение большого числа на небольшое, умножение двух небольших чисел и т. д.).
\item \textbf{Факториал:} Используйте написанный оператор для вычисления факториала от 1000. \\
Правильный ответ:
\begin{verbatim}
1000! = 40238726007709377354370243392300398571937486421071463254379991042993851239862902059
2044208486969404800479988610197196058631666872994808558901323829669944590997424504087073759
9188236277271887325197795059509952761208749754624970436014182780946464962910563938874378864
8733711918104582578364784997701247663288983595573543251318532395846307555740911426241747434
9347553428646576611667797396668820291207379143853719588249808126867838374559731746136085379
5345242215865932019280908782973084313928444032812315586110369768013573042161687476096758713
4831202547858932076716913244842623613141250878020800026168315102734182797770478463586817016
4365024153691398281264810213092761244896359928705114964975419909342221566832572080821333186
1168115536158365469840467089756029009505376164758477284218896796462449451607653534081989013
8544248798495995331910172335555660213945039973628075013783761530712776192684903435262520001
5888535147331611702103968175921510907788019393178114194545257223865541461062892187960223838
9714760885062768629671466746975629112340824392081601537808898939645182632436716167621791689
0977991190375403127462228998800519544441428201218736174599264295658174662830295557029902432
4153181617210465832036786906117260158783520751516284225540265170483304226143974286933061690
8979684825901254583271682264580665267699586526822728070757813918581788896522081643483448259
9326604336766017699961283186078838615027946595513115655203609398818061213855860030143569452
7224206344631797460594682573103790084024432438465657245014402821885252470935190620929023136
4932734975655139587205596542287497740114133469627154228458623773875382304838656889764619273
8381490014076731044664025989949022222176590433990188601856652648506179970235619389701786004
0811889729918311021171229845901641921068884387121855646124960798722908519296819372388642614
8396573822911231250241866493531439701374285319266498753372189406942814341185201580141233448
2801505139969429015348307764456909907315243327828826986460278986432113908350621709500259738
9863554277196742822248757586765752344220207573630569498825087968928162753848863396909959826
2809561214509948717012445164612603790293091208890869420285106401821543994571568059418727489
9809425474217358240106367740459574178516082923013535808184009699637252423056085590370062427
1243416909004153690105933983835777939410970027753472000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000
\end{verbatim}


\iffalse
\item \textbf{Числа-градины:} Возьмём некоторое число $n$ и будем последовательно применять к нему следующую функцию:
\begin{equation*}
f(n) = 
    \begin{cases}
      n / 2,   &\textup{если n - четное}\\ 
      3 n + 1, &\textup{если n - нечетное}
    \end{cases}
\end{equation*}
В результате получится некоторая последовательность. Например, при $n = 7$ получится:
\begin{verbatim}
7 -> 22 -> 11 -> 34 -> 17 -> 52 -> 26 -> 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
\end{verbatim}
Последовательность доходит до 1. Вам нужно написать функцию, которая будет по начальному числу находить длину такой последовательности (\texttt{steps}) и максимальное число в этой последовательности(\texttt{max}). Например, для числа $7$, максимальное число в последовательности будет равно $52$, а длина последовательности -- $16$. Напишите программу, которая будет по начальному числу находить длину последовательности и максимальный элемент в ней.

Тесты для проверки:
\begin{verbatim}
n = 7                    steps = 16;      max = 52
n = 256                  steps = 8;       max = 256
n = 1117065              steps = 527;     max = 2974984576
n = 4761963248413673697  steps = 2337;    max = 9926927712374950744648

n = 90560792656972947582439785608972465789628974587264056284658721771
steps = 1630;     
max = 773658021643749360792171137214151494851244403993540980838080564520
\end{verbatim}
Для решения этой задачи нужно написать оператор сравнения и метод деления на 2 (оператор целочисленного деления можно не писать).
\fi

\item \textbf{Большие числа с использованием вектора:} Напишите новый класс \texttt{Integer}, который будет делать всё то же самое, что и \texttt{Number}, но не будет самостоятельно выделять память в куче. Вместо этого для хранения разрядов числа класс \texttt{Integer} будет использовать внутри себя класс \texttt{std::vector}. Этот класс должен находиться в новом файле \texttt{integer.hpp}.
\end{enumerate}

\subsection{Убегающая точка}

Предположим, что у нас есть комплексная функция $f(z) = z^2$. Выберем некоторое комплексное число $z_0$ и будем проводить следующие итерации: 
\begin{equation*}
\label{fractalseq}
z_1 = f(z_0)\quad z_2 = f(z_1)\quad ...\quad z_{k+1} = f(z_k)\quad ...
\end{equation*}
В зависимости от выбора точки $z_0$ эта последовательность либо разойдётся, либо останется в некоторой ограниченной области. Будем называть точку $z_0$ убегающей, если $z_k \rightarrow \infty$ при $k \rightarrow \infty$. Область неубегания для функции $z^2$, т.е. множество всех начальных значений $z_0$, при которых последовательность (\ref{fractalseq}) остаётся ограниченной, тривиальна -- это единичный круг. Но всё становится сложнее для функции вида $f(z) = z^2 + c$, где $c$ -- некоторое комплексное число. Для такой функции найти область неубегания можно только численно.

\begin{center}
\includegraphics[scale=0.6]{../images/complexplane.png}
\end{center}

\begin{enumerate}
\item \textbf{Множество Жюлиа} \\
Численно найдите область неубегания для функций вида $f(z) = z^2 + c$, где $c$ -- некоторое комплексное число. Для этого создайте изображение размера 800x800, покрывающую область \texttt{[-2:2]x[-2:2]} на комплексной плоскости. Для каждой точки этой плоскости проведите $N \approx 20$ итераций и, в зависимости от результата, окрасьте пиксель в соответствующий цвет (цвет можно подобрать самим, он должен быть пропорционален значению $z_N$ - меняться от яркого если $z_N$ мало и до черного если $z_N$ большое). Нарисуте изображения для $c = -0.4 + 0.6i$;\quad $c = -0.70 - 0.38i$;\quad $c = -0.80 + 0.16i$\quad  и\quad $c = 0.280 + 0.011i$.

Программа должна создавать изображения в формате \texttt{.ppm}. Для работы с изображениями в формате \texttt{.ppm} используйте класс \texttt{Image} из файла \texttt{code/fractal/image.hpp}. Для просмотра изображений в формате \texttt{.ppm} можно использовать программу IrfanView. Для комплексных чисел используйте класс \texttt{Complex} из файла \texttt{code/fractal/complex.hpp}. 
Начальный код для задачи лежит в файле \texttt{code/fractal/complex\_image.cpp}.

\item Добавьте параметры командной строки: 2 вещественных числа, соответствующие комплексному числу $c$, и целое число итераций $N$. 
\item \textbf{Множество Мандельброта} \\
Зафиксируем теперь $z_0 = 0$ и будем менять $c$. Численно найдите все параметры $c$, для которых точка $z_0$ не является убегающей. Для этого создайте изображение размера 800x800, покрывающую область \texttt{[-2:2]x[-2:2]} возможных значений $c$ на комплексной плоскости. Программа должна создавать файл \texttt{mandelbrot.ppm}.

\item \textbf{Анимация} \\
Программа \texttt{complex\_movie.cpp} создаёт множество изображений и сохраняет их в папку \texttt{animation} (если у вас нет такой папки -- создайте её). Эти изображения представляют собой отдельные кадры будущей анимации. Чтобы их объединить в одно видео можно использовать программу ffmpeg. (ffmpeg можно установить с помощью MSYS2. Или можно скачать тут: \href{https://www.ffmpeg.org/}{www.ffmpeg.org} и изменить переменную среды \texttt{PATH} в настройках системы.) После этого можно будет объединить все изображения в одно видео такой командой:
\begin{verbatim}
ffmpeg -r 60 -i animation/complex_%03d.ppm complex_movie.mp4
\end{verbatim}
Создайте анимацию из изображений множеств Julia при $c$ линейно меняющемся от $(-1.5 - 0.5i)$ до $i$.
\end{enumerate}

\end{document}