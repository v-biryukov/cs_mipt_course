/*
    Удаление элементов списка во время его прохода

    При работе со связным списком нам может понадобиться удалить некоторое количество элементов,
    обладающих определённым свойством. Например, мы хотим удалить из списка чисел все нечётные.
    Как это сделать?

    Так как из связного списка можно быстро удалять из любого места по итератору, то мы можем
    просто пройтись по списку и удалить необходимые элементы с помощью метода erase вот так:


        for (std::list<int>::iterator it = l.begin(); it != l.end(); ++it)
        {
            if (*it % 2 == 1)
                l.erase(it);
        }

    Но этот код приведёт к ошибке!
    Всё дело в устройстве связного списка. Так как каждый узел содержит указатель на следующий элемент,
    а при удалении элемента с помощью erase удаляется и соответствующий узел, то после удаления элемента
    мы не сможем перейти к следующему.
    То есть ++it приведёт к ошибке, так как узел, соответствующий итератору it был удалён.

    Но этот код можно исправить, воспользовавшись тем, что метод erase возвращает итератор на следующий
    элемент после удалённого.
*/

#include <iostream>
#include <list>
#include <string>
using std::cout, std::endl;

int main()
{
    std::list<int> l {10, 25, 30, 41, 59, 62, 78};


    for (std::list<int>::iterator it = l.begin(); it != l.end(); ++it)
    {
        cout << *it << ' ';
    }
    cout << endl;



    for (std::list<int>::iterator it = l.begin(); it != l.end(); ++it)
    {
        if (*it % 2 == 1)
            l.erase(it);
    }


    for (std::list<int>::iterator it = l.begin(); it != l.end(); ++it)
    {
        cout << *it << ' ';
    }
    cout << endl;
}


/*
    Задача:

        Исправьте код данной программы.
        Используйте то, что метод erase возвращает итератор на следующий после удалённого элемент.
*/
