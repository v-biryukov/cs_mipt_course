/*
    Контейнеры и итераторы STL

    Итераторы разных контейнеров обладают разным набором допустимых операторов.
    Например, для к итератору вектора мы можем прибавлять/отнимать целые числа и это работает за O(1).
    Но для итераторов двусвязного списка или итераторов множества мы не можем это делать.
    Такая операция для таких итераторов просто не реализована, а если и была реализована, то работала бы за O(n).
    Итераторы двусвязного списка и итераторы множества можно только увеличивать или уменьшать на 1.

    Но рассмотрим итератор для односвязного списка: std::forward_list<T>::iterator.
    Такой итератор мы даже не можем уменьшить на 1, то есть у него нет перегруженного operator--

    Получается итераторы делятся на категории и у каждой категории есть свой набор допустимых операторов.
    Тему категории операторов мы пройдём в следующем семинаре.


    Допустимые операции для всех итераторов контейнеров библиотеки STL:

        1)  Конструктор копирования
            Если нам известен один итератор, то мы можем создать другой, который будет являться его копией.

                Container::iterator it2 {it1};

        
        2)  Присваивание

                it2 = it1;


        3)  Инкремент итератора
            В этом случае итератор начинает указывать на следующий элемент.

                it++    ++it  


        4)  Сравнения на равенство, но НЕ на больше/меньше
            Можно сравнивать, указывают ли итераторы на один и тот же объект

                it1 == it2      it1 != it2 


        5)  Унарная звёздочка
            Поставив * перед итератором мы получим объект, на который указывает итератор

                *it

    Другие операции с итераторами могут быть доступны для некоторых итераторов (например, std::vector<T>::iterator)
    и не доступны для других (например, std::set<T>::iterator).
*/



#include <iostream>
#include <forward_list>
using std::cout, std::endl;

int main()
{
    std::forward_list<int> fl {10, 20, 30, 40, 50};
    std::forward_list<int>::iterator it = fl.begin();

    cout << *it << endl;

    it++;
    cout << *it << endl;
}


/*
    Задача:

        Протестируйте какие операции допустимы с итератором std::forward_list<T>::iterator
*/
