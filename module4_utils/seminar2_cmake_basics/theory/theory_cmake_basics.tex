\documentclass{article}
\usepackage[english,russian]{babel}
\usepackage{textcomp}
\usepackage{geometry}
  \geometry{left=2cm}
  \geometry{right=1.5cm}
  \geometry{top=1.5cm}
  \geometry{bottom=2cm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{listings}
\pagenumbering{gobble}

\lstdefinestyle{csMiptCppStyle}{
  language=C++,
  basicstyle=\linespread{1.1}\ttfamily,
  columns=fixed,
  fontadjust=true,
  basewidth=0.5em,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  texcl=true,
  stringstyle=\ttfamily\color{orange!50!black},
  showstringspaces=false,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  numberfirstline=true,
  stepnumber=1,      
  numbersep=10pt,
  backgroundcolor=\color{white},
  showstringspaces=false,
  captionpos=b,
  breaklines=true
  breakatwhitespace=true,
  xleftmargin=.2in,
  extendedchars=\true,
  keepspaces = true,
  tabsize=4,
  upquote=true,
}


\lstdefinestyle{csMiptCppLinesStyle}{
  style=csMiptCppStyle,
  frame=lines,
}

\lstdefinestyle{csMiptCppBorderStyle}{
  style=csMiptCppStyle,
  framexleftmargin=5mm, 
  frame=shadowbox, 
  rulesepcolor=\color{gray}
}


\lstdefinestyle{csMiptBash}{
breaklines=true,
frame=tb,
language=bash,
breakatwhitespace=true,
alsoletter={*()"'0123456789.},
alsoother={\{\=\}},
basicstyle={\ttfamily},
keywordstyle={\bfseries},
literate={{=}{{{=}}}1},
prebreak={\textbackslash},
sensitive=true,
stepnumber=1,
tabsize=4,
morekeywords={echo, function},
otherkeywords={-, \{, \}},
literate={\$\{}{{{{\bfseries{}\$\{}}}}2,
upquote=true,
frame=none
}




\lstset{style=csMiptCppLinesStyle}
\lstset{literate={~}{{\raisebox{0.5ex}{\texttildelow}}}{1}}


\renewcommand{\thesection}{\arabic{section}}
\makeatletter
\def\@seccntformat#1{\@ifundefined{#1@cntformat}%
   {\csname the#1\endcsname\quad}%    default
   {\csname #1@cntformat\endcsname}}% enable individual control
\newcommand\section@cntformat{Часть \thesection:\space}
\makeatother




\begin{document}
\title{Семинар \#2: CMake \vspace{-5ex}}\date{}\maketitle

\section{Системы сборки}
\begin{description}
\item \textbf{Сборка} (англ. \textit{build}) -- это процесс трансформации исходного кода и ресурсов в исполняемые исполняемые файлы и/или библиотеки.

\item \textbf{Система сборки} (англ. \textit{build system}) -- это программа (или набор программ), предназначенная для автоматизации преобразования исходного кода в исполняемые файлы или библиотеки. 
\end{description}



\subsection*{Задачи, которые решают системы сборки}
Представьте, что есть проект, написанный на C++, содержащий сотни файлов и зависящий от многих сторонних библиотек. Как его скомпилировать? Можно просто вызвать компилятор \texttt{g++} из командной строки и передать ему все файлы проекта, информацию о всех подключаемых библиотеках и все опции компиляции и линковки необходимые для проекта. В теории так можно скомпилировать даже большой проект, однако такой подход имеет множество недостатков. Например, вводимая команда будет очень большой и в ней можно будет легко  запутаться. Но это только одна из многих проблем данного подхода. 


Вот какие проблемы могут возникнуть, если компилировать программу просто с помощью компилятора (например, \texttt{g++}), без использования систем сборки:

\begin{itemize}
\item \textbf{Большое количество файлов исходного кода}\\
Проект может содержать сотни и тысячи файлов исходного кода. Для того, чтобы скомпилировать такой проект придётся передать все эти файлы компилятору. Можно будет легко ошибиться в названии какого-либо файла или просто забыть один из файлов.

\item \textbf{Множество опций компиляции}\\
Часто необходимо скомпилировать исходные файлы с использованием множества различных опций компиляции и линковки. Причём, часть файлов должны быть скомпилированы с одними опциями, а другая часть -- с другими опциями. Опции компиляции могут меняться при различных сборках. Например, в один момент мы можем захотеть собрать программу так, чтобы она была как можно более быстрой (то есть передать всем файлам опцию \texttt{-O3}). В другой раз мы можем захотеть собрать проект для его дебага (в этом случае нужно будет передать опции \texttt{-O0 -g}).

\item \textbf{Проект может зависеть от внешних библиотек}\\
Если проект зависит от внешних библиотек, то каждую библиотеку придётся подключить, используя специальные опции для компиляции (например, \texttt{-I}, \texttt{-L} и \texttt{-l}). Внешние библиотеки могут быть как статическими, так и динамическими, это также нужно учесть при сборке. 

\item \textbf{Внешние библиотеки необходимо найти в системе}\\
Если вы собирает проект на своей машине, то вы можете указать полные пути до внешних библиотек. Но если вы создаёте программу, которая должна компилироваться на других системах, то нужно учесть, что на разных компьютерах библиотеки могут находиться в разных местах в системе. Более того, нужных библиотек может просто не быть в системе. Или на системе может находиться нужная библиотека, но быть не подходящей версии. В этих случаях нужно будет вывести сообщение об ошибке либо попытаться загрузить библиотеку из сети прямо во время сборки.


\item \textbf{Несколько исполняемых файлов и/или библиотек в одном проекте}\\
Результатом сборки проекта необязательно является один файл. Проект может содержать множество исполняемых файлов и/или библиотек. Приведём расспространённые примеры когда это случается:
\begin{itemize}
\item \textbf{Разная функциональность}: Например, один исполняемый файл -- это само приложение, а другой исполняемый файл -- это редактор настроек основного приложения.

\item \textbf{Разный интерфейс}: Например, один исполняемый файл -- это приложение, которое вызывается только через командную строку, а второй файл -- это то же самое приложение, но с графическим интерфейсом.

\item \textbf{Компонентная архитектура приложения}: Например, один исполняемый файл -- это приложение-сервере, а второй файл -- приложение-клиент.

\item \textbf{Несколько компонент одной библиотеки}: Если библиотека большая, то она может делиться на несколько компонент. Каждая компонента по сути представляет собой самостоятельную библиотеку. Пользователь может выбрать какие компоненты библиотеки он хочет использовать.
\end{itemize}
Для компиляции каждого исполняемого файла и каждой библиотеки необходимо вызвать компилятор, корректно указав исполнямые файлы, опции компилятора и подключив внешние библиотеки. Естественно, опции компилятора будут разными для разных компонент проекта. Использование систем сборки позволяет упростить этот процесс.

\item \textbf{Инкрементальная сборка}\\
Предположим, что вы изменили один файл в уже скомпилиронном проекте. Чтобы собрать проект заново, можно перекомпилировать весь проект, однако это можно занять очень много времени (компиляция больших проектов может занимать несколько часов). Вместо этого можно использовать объектые файлы, сохранившиеся с момента предыдущей компиляции для гораздо более быстрой сборки. Если вы не используете систему сборки, то вам придётся самим хранить все эти файлы, самим определять какие файлы не сохранились с момента предыдущей сборки и перекомпилировать заново только изменившиеся файлы. Система сборки берёт эту работу на себя.


\item \textbf{Кроссплатформенность}\\
Мы хотим, чтобы наш проект собирался на разных архитектурах и операционных системах. Но сборка на разных системах может сильно отличаться. Может быть разным всё что угодно: разные системные библиотеки, разные компиляторы, разные опции компиляции, разные форматы файлов, разные расширения файлов и так далее вплоть до разного формата написания путей. Многие системы сборки берут на себя большую часть работы по сборке проекта на разных системах.


\item \textbf{Поддержка различных компиляторов}\\
Даже в рамках одой системы могут существовать множество различных компиляторов C++. Помимо \texttt{GCC} популярны такие компиляторы как \texttt{Clang} и \texttt{MSVC}. Есть также множество других компиляторов. Если мы захотим по какой-либо причине поменять компилятор, то мы сможем легко это сделать только если мы используем систему сборки.  

\item \textbf{Работа с дополнительными файлами проекта}\\
Помимо файлов исходного кода и файлов библиотек, проект может содержать множество других файлов, таких как файлы настроек проекта, скрипты на других языках программирования, файлы документации, ресурсы проекта (например, изображения значков в программе или текстуры в игре). При сборке проекта может понадобиться, например, проверить что такие файлы существуют или, например, разархивировать их или скачать файлы из сети.
\end{itemize}


\subsection*{Системы сборки для языков C и C++}
Для языка C++ существуют множество систем сборки, вот самые популярные из них:
\begin{itemize}
\item \textbf{Make} -- классическая система сборки, часто используется в Linux для языка C.
\item \textbf{CMake} -- самая популярная система сборки для проектов на языке C++.\\ Является не просто системой сборки, но и генератором для других систем.
\item \textbf{Meson} -- альтернатива CMake, но менее популярна.
\item \textbf{Bazel} -- система сборки для разных языков (C++, Java, Python), разработанная Google.
\item \textbf{Ninja} -- минималистичная система сборки, ориентированная на скорость.
\item \textbf{MSBuild} -- система сборки, разработанная Microsoft, используется в IDE Visual Studio.

\item \textbf{Qmake} -- система сборки библиотеки Qt, но может использоваться и для обычных проектов.
\end{itemize}



\newpage
\section{Что такое CMake?}
\begin{itemize}
\item \textbf{CMake -- это генератор систем сборки}\\
CMake не компилирует код напрямую, а создаёт файлы сборки для других систем, таких как Make, Ninja, Visual Studio или других. Вы можете указать, какую систему использовать. После генерации файлов, соответствующая система собирает проект.
\item \textbf{CMake -- это система сборки}\\
CMake может автоматически запускать системы сборки для компиляции проекта. Это позволяет полностью собирать проект, используя только CMake. Например, можно сгенерировать проект для Visual Studio и скомпилировать его без запуска самой Visual Studio. Поэтому CMake часто считают не просто генератором, а полноценной системой сборки.
\item \textbf{CMake -- это язык программирования}\\
CMake использует собственный скриптовый язык для описания сборки. Этот язык проще традиционных языков программирования, но при этом остаётся полноценным — он поддерживает переменные, функции и условия, позволяя гибко настраивать процесс сборки.
\end{itemize}

\subsection*{Установка CMake}

\subsubsection*{Windows, с использованием пакетного менеджера MSYS2}
Если вы используете MSYS2, то CMake можно установить, открыв  терминал MSYS2 (\texttt{Пуск}  \textrightarrow{} \texttt{MSYS2 MSYS}) и выполнив следующую команду:
\begin{verbatim}
$ pacman -S cmake
\end{verbatim}
или такую команду:
\begin{verbatim}
$ pacman -S mingw-w64-x86_64-cmake
\end{verbatim}

\subsubsection*{Windows, с использованием установщика}
Перейти на оффициальный сайт: \href{https://cmake.org/}{\texttt{cmake.org}} и скачать установщик для вашей системы оттуда. Для Windows вам потребуется скачать следующее:
\texttt{cmake.org} \textrightarrow{} Download \textrightarrow{} Binary distributions \textrightarrow{} Windows x64 Installer.

\subsubsection*{Linux}
Используйте пакетный менеджер системы, например:
\begin{verbatim}
sudo apt install cmake
\end{verbatim}

\subsection*{Сборка HelloWorld с помощью CMake}

\subsection*{CMake как генератор систем сборки}


\newpage
\section{Простые проекты с использованием CMake}

\section{Таргеты}

\subsection*{\texttt{PUBLIC}, \texttt{PRIVATE} и \texttt{INTERFACE}}

\section{CMake как язык программирования}


\subsection*{Печать на экран. Команда \texttt{message}.}

\subsection*{Переменные в CMake}

\subsection*{Команда \texttt{string}}

\subsection*{Списки в CMake. Команда \texttt{list}.}

\subsection*{Алгоритм передачи аргументов в функции}

\subsection*{Команда \texttt{if}}

\subsubsection*{Алгоритм определения истинности/ложности выражения, передаваемого в \texttt{if}}
Пусть в \texttt{if} передаётся одна строка, которую обозначим как \texttt{value}:
\begin{verbatim}
if(value)
\end{verbatim}
Для определения истинности/ложности выражения \texttt{value}, используется следующий алгоритм:
\begin{itemize}
\item Если \texttt{value} это одна из следующих строк, то \texttt{value} расценивается как истина: 
\begin{itemize}
\item \texttt{ON}, \texttt{YES}, \texttt{TRUE}, \texttt{Y}
\item Одна из перечисленных строк, с изменёнными регистрами символов.
\item Строка, представляющее ненулевое число.
\end{itemize}

\item Если \texttt{value} это одна из следующих строк, то \texttt{value} расценивается как ложь:  
\begin{itemize}
\item \texttt{OFF}, \texttt{NO}, \texttt{FALSE}, \texttt{N}, \texttt{IGNORE}, \texttt{NOTFOUND}
\item Строка, оканчивающаяся на \texttt{-NOTFOUND}
\item Одна из перечисленных строк, с изменёнными регистрами символов.
\item Строка, представляющее число 0.
\item Пустая строка.
\end{itemize}


\item В остальных случаях действуют следующие правила:
\begin{itemize}
\item Если \texttt{value} это строка, обрамлённая в "кавычки"{}, то \texttt{value} расценивается как ложь.
\item Если \texttt{value} это строка, не обрамлённая в "кавычки"{}, то \texttt{value} воспринимается как переменная. Значение этой переменной автоматически подставляется. Дальше, используются правила, описанные выше в первых двух пунктах алгоритма. В частности, если переменной с данным именем не существует, то она воспринимается как пустая строка и расценивается как ложь. Если переменная имеет значение неописанное в первых двух пунктах алгоритма, то \texttt{value} расценивается как истина.
\end{itemize}
\end{itemize}

\subsection*{Циклы CMake}


\subsection*{Функции CMake}


\subsection*{Работа с файлами в CMake}


\end{document}
